#+TITLE: Emacs Configuration
#+AUTHOR: Drew Barbarello

* About
My emacs configuration inspired by [[http://endlessparentheses.com/init-org-Without-org-mode.html][this]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][this]].

* Dependencies
The packages configured by this file require the following to be used
to their fullest extent:
- Emacs >= 24.5 (for magit)
- Git >= 1.9.4 (for magit)
- =clang-format=
- Python + IPython >= 5 + Jupyter >= 1.0 for [[https://github.com/gregsexton/ob-ipython][ob-ipython]]
- Rust: install rust-analyzer using the instructions [[https://rust-analyzer.github.io/manual.html#emacs][here]]
- =elpy= dependencies:
  - =rope=
  - =jedi=
  - =flake8=
  - =autopep8=
  - =yapf=

    Arch install command:
    #+begin_src sh
  sudo pacman -S python-rope python-jedi flake8 autopep8 yapf
    #+end_src

* Personal
#+begin_src emacs-lisp
(setq user-full-name "Andrew Barbarello"
      user-email-address "andrew.barbarello@outlook.com")
#+end_src

* Initialization

** =use-package=
Inspired by [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][this]] post, using =use-package= to ensure packages are
installed and initialize them lazily.

=use-package= can integrate with =diminish= mode to hide minor modes from
the command line. =diminish= is [[https://github.com/jwiegley/use-package/commit/2c345ccc0eb4f2f3e26fe186d3f71f2b1b87b922][now]] an optional dependency of
=use-package=, so we'll go ahead and install it ourselves.

#+begin_src emacs-lisp
;; bootstrap `use-package', at the same time ensure we install org mode
;; from elpa
(unless (and (package-installed-p 'use-package)
             (package-installed-p 'diminish))
  (package-refresh-contents)
  (package-install 'use-package)
  (package-install 'diminish)
  (package-install-from-archive
   (car (alist-get 'org package-archive-contents))))
#+end_src

** Environment
#+begin_src emacs-lisp
(defvar current-user
      (getenv
       (if (equal system-type 'windows-nt) "USERNAME" "USER")))

;; equivalent of prelude-dir
(defvar init-dir user-emacs-directory
  "The root dir of the Emacs configuration.")

(add-to-list 'load-path (expand-file-name "misc" init-dir))
#+end_src

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :demand
  :config
  (when (daemonp)
    (exec-path-from-shell-initialize)))
#+end_src

** Package archives
I configure the list of package archives to pull from in [[file:init.el][=init.el=]],
because Emacs 25 insisted on sticking a =(package-initialize)= call in
the head of that file.

** =auto-compile=
Package to ensure previously byte-compiled files never shadow changes
in the corresponding source (=.el=) file.
#+begin_src emacs-lisp
(setq load-prefer-newer t)
(use-package auto-compile
  :ensure t
  :config (auto-compile-on-load-mode))
#+end_src

** =custom-file=
The place where =custom-set-variables= decisions are persisted.
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom-settings.el" init-dir))
(load custom-file t)
#+end_src

** Startup buffer
Show =*scratch*= buffer on startup, rather than splash screen.
#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
#+end_src

* Global
** Editing
Universal editing configuration: how to handle whitespace, etc.
Largely lifted from =prelude-editor.el=.
*** Whitespace
#+begin_src emacs-lisp
;; Death to the tabs!  However, tabs historically indent to the next
;; 8-character offset; specifying anything else will cause *mass*
;; confusion, as it will change the appearance of every existing file.
;; In some cases (python), even worse -- it will change the semantics
;; (meaning) of the program.
;;
;; Emacs modes typically provide a standard means to change the
;; indentation width -- eg. c-basic-offset: use that to adjust your
;; personal indentation width, while maintaining the style (and
;; meaning) of any files you load.
(setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
(setq-default tab-width 8)            ;; but maintain correct appearance

;; Newline at end of file
(setq require-final-newline t)
#+end_src

**** =whitespace-mode=
Clean whitespace on save, highlight whitespace in buffers. A subtle
bit here is the =advice-add= call that runs =whitespace-cleanup= on
"save" in =Org Src= buffers. Saving in such a buffer persists the
code block change back to the parent Org file, but it /doesn't/ run
=before-save-hook=, so the expected behavior that whitespace is
cleaned on =C-x C-s= doesn't occur unless you add it as function advice.
#+begin_src emacs-lisp
(defun my/enable-whitespace ()
  "Enable `whitespace-mode' and invoke `whitespace-cleanup' on file save."
  (add-hook 'before-save-hook #'whitespace-cleanup nil t)
  ;; Run whitespace-cleanup on an Org Src buffer on "save" back to the parent file
  (advice-add 'org-edit-src-save :before #'whitespace-cleanup)
  (whitespace-mode +1))

;; In some programming modes, I want more wiggle room before line length warning
(defun my/bump-line-len ()
  (setq whitespace-line-column 110))

(use-package whitespace
  :diminish whitespace-mode
  :config
  (setq whitespace-line-column 80)
  (setq whitespace-style '(face tabs empty trailing lines-tail))
  (add-hook 'text-mode-hook #'my/enable-whitespace)
  (add-hook 'prog-mode-hook #'my/enable-whitespace)
  (add-hook 'python-mode-hook #'my/bump-line-len))
#+end_src

*** Matching pairs (=smartparens-mode= and more)

The following block defines some keymappings for wrapping the active
region with a character (taken from Prelude), it requires =smartparens-mode=.

#+begin_src emacs-lisp
(defun prelude-wrap-with (s)
  "Create a wrapper function for smartparens using S."
  `(lambda (&optional arg)
     (interactive "P")
     (sp-wrap-with-pair ,s)))

(defun partial-map-add (key fun)
  "Given a keymapping KEY -> FUN, return a function that takes a
keymap and adds the given mapping"
  `(lambda (keymap)
     (define-key keymap ,key ,fun)))

(setq my/wrap-mappings
      (mapcar (lambda (pair) (partial-map-add (car pair) (cdr pair)))
        '(((kbd "M-\"") . (prelude-wrap-with "\""))
          ((kbd "M-(") . (prelude-wrap-with "("))
          ((kbd "M-[") . (prelude-wrap-with "[")))))

(defun my/add-wrap-mappings (map)
  (mapc (lambda (mapping) (funcall mapping map)) my/wrap-mappings))

(my/add-wrap-mappings prog-mode-map)
(add-hook 'c-initialization-hook
          (lambda () (my/add-wrap-mappings c-mode-base-map)))
#+end_src

Here, we setup =smartparens= to show matching pairs and install its
=paredit=-style bindings.

#+begin_src emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :config
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)
  (setq sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1))
#+end_src

*** Typing replaces selection
Another bit of config from Prelude that I didn't realize I needed
until I ran Emacs without it. With this setting, typing replaces an
active selection, whereas the default behavior is that text is just
inserted at point regardless of the selection.

#+begin_src emacs-lisp
(delete-selection-mode +1)
#+end_src

*** =auto-fill-mode=
For programming modes, define the function =comment-auto-fill= to
disable auto-fill except for on comments. Taken from [[https://www.emacswiki.org/emacs/AutoFillMode][here]].

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'turn-on-auto-fill)
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(diminish 'auto-fill-function)
#+end_src

*** Expand at point

**** =company-mode=
#+begin_src emacs-lisp
(use-package company
  :ensure t
  :config
  (setq company-tooltip-align-annotations t)
  ;; Easy navigation to candidates with M-<n>
  (setq company-show-numbers t)
  (setq company-dabbrev-downcase nil)
  (add-hook 'c-initialization-hook
            (lambda ()
              (define-key c-mode-base-map (kbd "M-/") #'company-complete)))
  (define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
  (define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)
  (global-company-mode)
  :diminish company-mode)
#+end_src

**** =company-quickhelp=
Show a documentation popup for company completion candidates

#+begin_src emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config
  (company-quickhelp-mode 1))
#+end_src

**** =hippie-expand=
Setup =hippie-expand=, which completes the word before point using one
of a variety of sources. Another bit of config taken verbatim from
Prelude

#+begin_src emacs-lisp
;; hippie expand is dabbrev expand on steroids
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))
(global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

**** =abbrev=
Enable =abbrev= for =text-mode= buffers.

#+begin_src emacs-lisp
(setq abbrev-file-name (expand-file-name "abbrev_defs" init-dir))
(add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
(diminish 'abbrev-mode)
#+end_src

Check out the manual for =abbrev-mode= [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs][here]]. In brief, the important
keybindings are:

- =C-x a g= :: Add global abbreviation for the word before point.
               Can call with a numeric prefix argument \(n\) to
               specify the number of words prior to point to define
               the abbreviation for.
- =C-x a l= :: Define an abbreviation as above, but that only applies
               to the current major mode.
- =C-x a i g= :: Use word before point as an abbreviation for a phrase
                 you define in the minibuffer.
- =M-x kill-all-abbrevs= :: Discard all abbrev definitions.

In order to type a prefix to an abbreviation (text that precedes the
expanded abbreviation without whitespace in between): type the prefix,
then type =M-=' followed by the abbreviation.

To type an abbreviation /without/ having it expand, type =C-q <SPC>=.

*** General indentation/formatting
Setup indentation/formatting bindings that apply in (nearly) any major
mode.

First, setup =<TAB>= to first indent the current line, then if the
line is already indented, complete the thing at point.
#+begin_src emacs-lisp
(setq tab-always-indent 'complete)
#+end_src

The next bit of code from Prelude makes =indent-region= and =untabify=
act on the whole buffer if called without an active region.

#+begin_src emacs-lisp
(defmacro with-region-or-buffer (func)
  "When called with no active region, call FUNC on current buffer."
  `(defadvice ,func (before with-region-or-buffer activate compile)
     (interactive
      (if mark-active
          (list (region-beginning) (region-end))
        (list (point-min) (point-max))))))

(use-package tabify
  :config
  (with-region-or-buffer indent-region)
  (with-region-or-buffer untabify))
#+end_src

*** EditorConfig
    :PROPERTIES:
    :CUSTOM_ID: general-editorconfig
    :END:

#+begin_src emacs-lisp
(use-package editorconfig
  :ensure t
  :diminish editorconfig-mode
  :config
  (add-hook 'prog-mode-hook (editorconfig-mode 1))
  (add-hook 'text-mode-hook (editorconfig-mode 1)))
#+end_src

*** =flycheck=
#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode))
#+end_src
*** =lsp-mode=
Referenced [[https://www.mortens.dev/blog/emacs-and-the-language-server-protocol/][this]] guide while setting it up.

#+begin_src emacs-lisp
;; setting lsp-keymap-prefix per https://github.com/emacs-lsp/lsp-mode/issues/1532#issuecomment-602384182
(use-package which-key :ensure t)

(use-package lsp-mode
  :ensure t
  :hook ((rust-mode . lsp)
         (c++-mode . lsp)
         (lsp-mode . (lambda ()
                       (let ((lsp-keymap-prefix "C-c l"))
                         (lsp-enable-which-key-integration)))))
  :config
  (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
  (setq lsp-keymap-prefix "C-c l") ; the default "s-l" is taken by my WM
  (setq lsp-prefer-flymake nil)
  (setq lsp-clients-clangd-args '("-j=4" "-background-index" "-log=error"))
  (setq lsp-completion-provider :capf)
  (add-hook 'lsp-ui-mode-hook  #'my/turn-off-annoying-lsp-ui t))

(defun my/turn-off-annoying-lsp-ui ()
  (lsp-ui-doc-mode -1)
  (lsp-ui-sideline-mode -1))

(use-package lsp-ui
  :ensure t
  :requires (lsp-mode flycheck)
  :config
  (setq lsp-ui-flycheck-enable t))
#+end_src
*** Compile keybind
From https://emacs.stackexchange.com/a/10950
#+begin_src emacs-lisp
(global-set-key (kbd "C-c m") 'recompile)
#+end_src

*** Enable commands

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'downcase-region 'disabled nil)
#+end_src

** Appearance
*** Theme
Using leuven, along with powerline

#+begin_src emacs-lisp
(setq column-number-mode t)

(use-package leuven-theme
  :ensure t
  :pin melpa
  :config (load-theme 'leuven :no-confirm))

(use-package powerline
  :ensure t
  :config
  (powerline-default-theme))
#+end_src

Leuven theme doesn't make overdue agenda items sufficiently prominent

#+begin_src emacs-lisp
(eval-after-load 'org
  (set-face-attribute 'org-scheduled-previously nil
                    :foreground "red" :weight 'bold))
#+end_src

*** Font
Set font size to 13 point (height value is in 1/10 pt)
#+begin_src emacs-lisp
(defun my/have-font (font)
  (member font (font-family-list)))

(defun my/setup-fonts (frame)
  (when frame
    (select-frame frame)
    (remove-hook 'after-make-frame-functions #'my/setup-fonts))
  (set-face-attribute 'default nil :height 130)
  (let ((ft
         (cond ((my/have-font "Source Sans Pro") '(:font "Source Sans Pro"))
               ((my/have-font "Lucida Grande") '(:font "Lucida Grande"))
               ((my/have-font "Sans Serif") '(:family "Sans Serif")))))
    ;; set the variable-pitch face to use font we found
    (eval `(set-face-attribute 'variable-pitch nil ,@ft)))
  ;; https://www.reddit.com/r/emacs/comments/ggd90c/color_emoji_in_emacs_27/
  ;; Emoji: üòÑ, ü§¶, üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø
  (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
  (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
  (set-fontset-font t 'symbol "Symbola" nil 'append)
  (when (my/have-font "Source Code Pro")
    (set-face-attribute 'default nil :font "Source Code Pro" :height 130)))

(if (daemonp)
    (add-hook 'after-make-frame-functions #'my/setup-fonts)
  (my/setup-fonts nil))

(defun my/variable-pitch-hook-set-cursor ()
  "Set the `cursor-type' to `bar' when entering variable-pitch mode, and
restore the original when leaving."
  (if (and buffer-face-mode
           (eq buffer-face-mode-face 'variable-pitch))
      (progn
        (setq-local buf-old-cursor-type cursor-type)
        (setq cursor-type 'bar))
    (setq cursor-type
          (if (boundp 'buf-old-cursor-type) buf-old-cursor-type))))
(add-hook 'buffer-face-mode-hook #'my/variable-pitch-hook-set-cursor)
#+end_src

#+begin_src emacs-lisp
;; Font size
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(diminish 'text-scale-mode)
#+end_src

*** Disable Window Chrome
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

*** Make =point= easier to find
Animate the current line when making point jump/activating point in
another window
#+begin_src emacs-lisp
;; show the cursor when moving after big movements in the window
(use-package beacon
  :diminish 'beacon-mode
  :ensure t
  :config (beacon-mode +1))
#+end_src

*** "Night mode"
#+begin_src emacs-lisp
(defun nighttime ()
  (interactive)
  (disable-theme 'leuven)
  (load-theme 'monokai)
  (powerline-reset))
#+end_src
** Behavior
*** Ask for confirmation before quitting
#+begin_src emacs-lisp
(defun my/confirm-kill-eclient ()
  (interactive)
  (if (yes-or-no-p "Are you sure you want to exit Emacs? ")
      (save-buffers-kill-terminal)))
(global-set-key (kbd "C-x C-c") #'my/confirm-kill-eclient)
#+end_src

*** Auto refresh buffer when associated file changes
#+srcname: name
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(diminish 'auto-revert-mode)
#+end_src

*** Change "yes or no" to "y or n"
Type out the full strings "yes" and "no"? Ain't nobody got time for that.
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Disambiguate buffers with the same name
#+begin_src emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)     ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+end_src

*** Undo tree
=C-x u= on steroids: browse history of edits (undo and redo).
#+begin_src emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :ensure t
  :config
  ;; autosave the undo-tree history
  (setq undo-tree-history-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq undo-tree-auto-save-history t)
  (global-undo-tree-mode))
#+end_src

*** =anzu=
Use =anzu= to improve isearch/query-replace by highlighting
matches/showing a preview of the replacement as you type

#+begin_src emacs-lisp
(use-package anzu
  :ensure t
  :diminish anzu-mode
  :bind (("M-%" . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp))
  :config
  (global-anzu-mode))
#+end_src

*** Sentences end with a single space
Saw this in Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][config]], and adopting it here. Allows
=forward-sentence= (=M-e=) and =backward-sentence= (=M-a=) to work as
expected.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

*** Window Management
Referring to /emacs/ windows, not /window manager/ windows (a.k.a. emacs "frames")
**** Prefer vertical splits
From [[http://stackoverflow.com/a/25587333/756104][this]] stack overflow answer, opens a new window with a vertical
split if there's sufficient room available, otherwise uses a
horizontal split.
#+begin_src emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 200)
#+end_src
**** Transpose Windows
Bind =C-c y= to transpose windows (a vertical split becomes a
horizontal one and vice versa). =C-c f= will swap buffers across $y$
axis, =C-c F= will swap buffers across $x$ axis.
#+begin_src emacs-lisp
(use-package transpose-frame
  :ensure t
  :bind (("C-c y" . transpose-frame)
         ("C-c f" . flop-frame)
         ("C-c F" . flip-frame)))
#+end_src

**** Toggle window dedicated
Useful to get a window (like a help window) to not be taken over by
other commands that open windows
#+begin_src emacs-lisp
(defun my/toggle-window-dedicated ()
  (interactive)
  (let ((cur-window (frame-selected-window)))
    (set-window-dedicated-p cur-window (not (window-dedicated-p cur-window)))))

(global-set-key (kbd "C-c d") #'my/toggle-window-dedicated)
#+end_src
*** Backups/Persistence
Pretty much all this stuff is copied verbatim from Prelude. It gets
the =backup~= files out of the way, remembers where you last left in a
file, remembers minibuffer history, etc.

#+begin_src emacs-lisp
(defvar my/savefile-dir (expand-file-name "savefile" init-dir)
  "This folder stores all the automatically generated save/history-files.")

(unless (file-exists-p my/savefile-dir)
  (make-directory my/savefile-dir))
#+end_src

Store all backup files in temp directory, so as to not pollute the
project directory.
#+begin_src emacs-lisp
;; store all backup and autosave files in the tmp dir
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

*** Don't ring bell on macOS
That behavior is annoying
#+begin_src emacs-lisp
(setq ring-bell-function #'ignore)
#+end_src

** Navigation
*** =helm=
An all-encompassing completion package. See [[https://github.com/emacs-helm/helm/wiki#helm-interaction-model][here]] for
philosophy/essential keybindings.

To "helm" a command, use the =helm-command-prefix-key=: =C-x c=. E.g.
=C-x c M-x= runs =helm-M-x=.

#+begin_src emacs-lisp
(use-package helm-config :ensure helm)
(use-package helm
  :after helm-config
  :diminish helm-mode
  :bind (("M-x" . helm-M-x)
         ("M-s o" . helm-occur)
         ("C-h a" . helm-apropos)
         ("C-x r b" . helm-filtered-bookmarks)
         ("C-x b" . helm-buffers-list)
         ("M-y" . helm-show-kill-ring)
         ("C-x C-b" . helm-mini)
         ("C-x C-f" . helm-find-files))
  :config
  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "M-r") #'helm-eshell-history)))
  (setq helm-M-x-reverse-history t)
  (helm-mode 1))
#+end_src

**** Find
Use =helm-find= to accomplish =find . | grep=-like functionality. In
=helm-find-files= (=C-x C-f=), type =C-c /= to recursively find files
in the selected directory with names containing the given pattern.

*** =ace-window=
Press =M-o= and each window in the frame will have a label you can press
to quickly jump to it. As a special case, if there are only two
windows in the frame, =M-o= causes the focus to immediately switch to
the other window.

#+begin_src emacs-lisp
(use-package ace-window
  :ensure t
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-scope 'frame)
  :bind (("M-o" . ace-window)))
#+end_src

*** Jump to char with =avy=
Use =avy=, based on =ace-jump-mode= and =vim-easymotion=.

- Jump to a character using =C-:=
- Jump to a character (after entering two characters) using =C=' (does
  not work in org mode, because this is instead bound to org-cycle-agenda-files
- Jump to a line with =M-g f=
- Jump to a word with =M-g w= (like =avy-goto-char=, but only matches
  that character at the beginning of a word.

#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind (("C-:" . avy-goto-char)
         ("C-'" . avy-goto-char-2)
         ("M-g '" . avy-goto-char-2)
         ("M-g l" . avy-goto-line)
         ("M-g w" . avy-goto-word-1)))
#+end_src


**** =recentf-mode=
I use =recentf-open-files= all the time.
#+begin_src emacs-lisp
(defun prelude-recentf-exclude-p (file)
  "A predicate to decide whether to exclude FILE from recentf."
  (let ((file-dir (file-truename (file-name-directory file))))
    (-any-p (lambda (dir)
              (string-prefix-p dir file-dir))
            (mapcar 'file-truename (list my/savefile-dir package-user-dir)))))

;; Taken from https://gist.github.com/masutaka/1325654/09b1cc94258f63e251cf74806499ce92225edd26
;; to avoid extraneous writes to the minibuffer
(defvar my/recentf-list-prev nil)
(defun my/setup-recentf-advice ()
  (defadvice recentf-save-list
      (around no-message activate)
    "If `recentf-list' and previous recentf-list are equal,
do nothing. And suppress the output from `message' and
`write-file' to minibuffer (still shows up in *Messages* buffer)."
    (unless (equal recentf-list my/recentf-list-prev)
      (let ((inhibit-message t))
        ad-do-it
        (setq my/recentf-list-prev recentf-list)))))

(use-package recentf
  :bind ("C-x C-r" . helm-recentf)
  :config
  (my/setup-recentf-advice)

  (setq recentf-save-file (expand-file-name "recentf" my/savefile-dir)
        recentf-max-saved-items 500
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)
  (add-to-list 'recentf-exclude 'prelude-recentf-exclude-p)
  (add-to-list 'recentf-exclude "/recentf\\'")
  (recentf-mode +1)
  (run-at-time nil 10 #'recentf-save-list))
#+end_src

**** Save place in file
#+begin_src emacs-lisp
(use-package saveplace
  :ensure t
  :config
  (setq save-place-file (expand-file-name "saveplace" my/savefile-dir))
  ;; activate save-place for all buffers
  (setq-default save-place t))
#+end_src


**** Save minibuffer history
From Prelude, configure =savehist= to store the last few commands run
in the minibuffer, which persists across runs of emacs.
#+begin_src emacs-lisp
(use-package savehist
  :ensure t
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        savehist-file (expand-file-name "savehist" my/savefile-dir))
  (savehist-mode +1))
#+end_src

*** =projectile=
#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-global-mode)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

#+begin_src emacs-lisp
(use-package helm-projectile
  :ensure t
  :config
  (helm-projectile-on))
#+end_src

*** =google-this=
=google-this=, bound to =C-c / t=. It also comes with a function to google
cppreference (=C-c / r=).
#+begin_src emacs-lisp
(use-package google-this
  :ensure t
  :diminish google-this-mode
  :config
  (google-this-mode 1))
#+end_src

** Snippets
Fetch yasnippet, add the =other-snippets= directory to the path (where
I pull in additional snippets via git submodules).
#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :ensure t
  :defer 2
  :config
  (setq yas-snippet-dirs
        `(,(expand-file-name "other-snippets" init-dir)
          ,(expand-file-name "snippets" init-dir)))
  (yas-global-mode 1)
  (yas-reload-all))
#+end_src

** Git

*** =magit-mode=
#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status))
#+end_src

*** Highlight uncommitted changes
#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :pin melpa
  :config
  (global-diff-hl-mode +1)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))
#+end_src
*** Expand outline when diffing
Useful for diffing org mode
#+begin_src emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+end_src

** =flyspell-mode=
Flyspell config, appropriate from Prelude.
#+begin_src emacs-lisp
(defun prelude-enable-flyspell ()
  "Enable command `flyspell-mode' if ispell program is available"
  (when (executable-find ispell-program-name)
    (flyspell-mode +1)))

(use-package flyspell
  :ensure t
  :diminish flyspell-mode
  :config
  (setq ispell-program-name "aspell" ; use aspell instead of ispell
        ispell-extra-args '("--sug-mode=ultra"))
  (add-hook 'text-mode-hook #'prelude-enable-flyspell))
#+end_src
** =devhelp=
#+begin_src emacs-lisp
(setq my/devhelp-path (executable-find "devhelp"))
;; adapted from https://git.gnome.org/browse/devhelp/tree/misc/devhelp.el
(defun my/devhelp-word-at-point ()
  "Searches for the current word in devhelp, if available"
  (interactive)
  (if (not my/devhelp-path)
      (message "devhelp executable could not be located")
    (start-process-shell-command "devhelp" nil
                                 (mapconcat #'identity (list my/devhelp-path "-s" (current-word)) " "))
    (set-process-query-on-exit-flag (get-process "devhelp") nil)))
(global-set-key [f7] #'my/devhelp-word-at-point)
#+end_src
* Eshell
#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook
          (lambda ()
            (add-to-list 'eshell-visual-subcommands '("git" "log" "diff" "show"))))
#+end_src
* Org Mode
** Global Bindings
#+begin_src emacs-lisp
  (use-package org-variable-pitch
    :diminish org-variable-pitch-minor-mode
    :config
    (defun my/org-init ()
      (org-variable-pitch-minor-mode +1)
      (diminish 'buffer-face-mode)
      (setq org-hide-emphasis-markers t))
    (add-hook 'org-mode-hook #'my/org-init))

  (use-package org
    :ensure t
    :bind (("C-c l" . org-store-link)
           ("M-p" . org-metaup)
           ("M-n" . org-metadown))
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((python . t)
       (shell . t))))
  (use-package org-agenda :bind ("C-c a" . org-agenda))
  (use-package org-capture :bind ([f6] . org-capture))
#+end_src
*** Org-Ref
A very cool/helpful package to manage citations in org file/take notes
for citations.

Workflow:
1. Create a =notes.org= file on a topic
2. Put this somewhere in the file: =bibliography:refs.bib=
3. Add a paper's bibtex to =refs.bib=
4. In =notes.org=, add a citation to the paper with =C-c ]=
5. Call =org-open-at-point= on the citation (=C-c C-o=)
6. Select =Add notes=

Don't have a good method for finding an entry yet. /Could/
1. Use =C-c ]= to create a citation, using helm to search bibtex entries
2. Open the new =cite= link (click or =C-c C-o=) and use the =Open bibtex= entry
3. At the =bibtex= entry, use =org-ref-open-bibtex-notes=

#+begin_src emacs-lisp
(defun my/org-ref-bibliography-format (orig-format keyword desc format)
  (cond
   ((eq format 'md) "")
   (t (apply orig-format keyword desc format nil))))

(defun my/org-ref-notes-function-one-file (key)
  "Function to open note belonging to KEY.
 Set `org-ref-notes-function' to this function if you use one
long file with headlines for each entry."
  ;; save key to clipboard to make saving pdf later easier by pasting.
  (with-temp-buffer
    (insert key)
    (kill-ring-save (point-min) (point-max)))
  (let* ((bibtex-entry (org-ref-get-bibtex-entry key))
         (entry (with-temp-buffer
		 (insert bibtex-entry)
		 (bibtex-mode)
		 (bibtex-beginning-of-entry)
		 (bibtex-parse-entry)) ))

    (save-restriction
      (widen)
      (goto-char (point-min))
      (let* ((headlines (org-element-map
			    (org-ref-parse-buffer)
			    'headline 'identity))
	     (keys (mapcar
		    (lambda (hl) (org-element-property :CUSTOM_ID hl))
		    headlines)))
	(if (-contains? keys key)
	    ;; we have it so we go to it.
	    (progn
	      (org-open-link-from-string (format "[[#%s]]" key))
	      (funcall org-ref-open-notes-function))
	  ;; no entry found, so add one
	  (goto-char (point-max))
	  (insert (org-ref-reftex-format-citation
		   entry (concat "\n" org-ref-note-title-format)))
	  (mapc (lambda (x)
		  (save-restriction
		    (save-excursion
		      (funcall x))))
		org-ref-create-notes-hook)
	  (save-buffer))))))

(use-package org-ref
  :ensure t
  :defer t
  :config
  (setq org-ref-notes-function 'my/org-ref-notes-function-one-file)
  (advice-add #'org-ref-bibliography-format
              :around #'my/org-ref-bibliography-format)
  (require 'org-ref-citeproc)
  (defun orcp-collect-citations ()
    "Return a list of citation links in the document."
    (setq *orcp-citation-links*
          (cl-loop for link in (org-element-map
                                   (org-element-parse-buffer) 'link 'identity nil nil nil t)
                   if (-contains?
                       org-ref-cite-types
                       (org-element-property :type link))
                   collect link)))
  (defun orcp-url (entry)
    (orcp-get-entry-field "url" entry)))
#+end_src

** Authoring Settings
*** Don't try and insert blank lines before new headings
#+srcname: name
#+begin_src emacs-lisp
(setq org-blank-before-new-entry (assq-delete-all 'heading org-blank-before-new-entry))
(push '(heading . nil) org-blank-before-new-entry)
#+end_src
*** Source block indentation
Disable Org's default behavior of indenting code from a source block
with spaces after saving back to buffer from =org-edit-src-code= (C-c ')
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
(setq org-edit-src-preserve-indentation nil)
#+end_src

*** Allow ordered lists with letters
#+begin_src emacs-lisp
(setq org-list-allow-alphabetical t)
#+end_src

*** Whitespace mode
Fix whitespace mode's naive =lines-tail= highlighting, so that only
the /description text/ of org mode links counts against the
=whitespace-line-column= limit. Inspired by example at
[[https://www.emacswiki.org/emacs/HighlightLongLines]].

#+begin_src emacs-lisp
;; a font-lock-keyword for org-mode. highlights parts of lines that extend past
;; whitespace-line-column, assuming that only the *description* of org links are
;; visible (and hence, only the descriptions count against the line length limit)

(defun my/advance-to-col (startpos startcol stopcol)
  "Given a start position STARTPOS in the current buffer, the column count
at point STARTPOS (STARTCOL) and desired end column (STOPCOL), return the
buffer position of character starting column (STOPCOL)"
  (let ((curpos startpos)
        (curcol startcol))
    (while (< curcol stopcol)
      (setq curcol (+ curcol (char-width (char-after curpos))))
      (setq curpos (1+ curpos)))
    curpos))

(defun my/next-long-org-line (limit)
  "Return the next tuple (start end) of positions from current value of (point) to
be marked as entending past line length LIMIT."
  (catch 'done
    (while (< (line-beginning-position) limit)
      (beginning-of-line)
      (let ((curcols 0)
            (lim (min limit (line-end-position)))
            (curpos (point)))
        (while (re-search-forward org-bracket-link-analytic-regexp lim t)
          (let ((mstartcol (+ curcols
                              (string-width (buffer-substring
                                             (match-beginning 0) curpos))))
                labelwidth
                labelstart)
            (if (match-string 5)
                ;; link of the form [[proto:link][description]]
                (setq labelwidth (string-width (match-string 5))
                      labelstart (match-beginning 5))
              ;; link of the form [[proto:something]]
              (setq labelwidth (string-width (match-string 3))
                    labelstart (match-beginning 3)))
            (when (> mstartcol whitespace-line-column)
              ;; link starts after whitespace-line-column, wholesale mark everything
              ;; after whitespace-line-column
              (throw 'done (list (my/advance-to-col curpos curcols whitespace-line-column) lim)))
            (when (> (+ mstartcol labelwidth) whitespace-line-column)
              ;; link starts before whitespace-line-column, but description (visible part)
              ;; extends past it
              (throw 'done (list (my/advance-to-col labelstart mstartcol whitespace-line-column) lim)))
            (setq curcols (+ mstartcol labelwidth)))
          (setq curpos (point)))
        ;; no org link match, see if line is just a long one
        (let* ((advancecols (string-width (buffer-substring (point) (line-end-position))))
               (excess-start (+ curcols advancecols)))
          (when (> excess-start whitespace-line-column)
            (throw 'done (list (my/advance-to-col curpos curcols whitespace-line-column) lim)))))
      (if (< (1+ (line-end-position)) (point-max))
          (forward-line)
        (throw 'done nil)))))

(defun my/match-long-org (limit)
  (let ((match-range (my/next-long-org-line limit)))
    (when match-range
      (set-match-data match-range)
      (goto-char (1+ (cadr match-range))))
    ;; if we didn't find a match, match-range is nil, and this matcher is done
    match-range))

(setq my/org-bline-minor-mode-font-lock-keywords
      '((my/match-long-org 0 whitespace-line prepend)))

(define-minor-mode my/org-bline-minor-mode "Overlong lines can make you blined."
  nil nil nil
  (if my/org-bline-minor-mode
      (font-lock-add-keywords nil my/org-bline-minor-mode-font-lock-keywords t)
    (font-lock-remove-keywords nil my/org-bline-minor-mode-font-lock-keywords))
  (font-lock-mode 1))

(defun my/org-bline-minor-mode--init ()
  (add-hook 'after-change-functions 'my/org-bline-minor-mode--fini nil t)
  ;; for debugging purposes, disable the JIT
  ;; (setq font-lock-support-mode nil)
  ;; (font-lock-mode -1)
  ;; (font-lock-mode 1)

  ;; get rid of the long line highlighting from whitespace-mode, we're doing
  ;; our own highlighting
  (whitespace-mode 0)
  (set (make-local-variable 'whitespace-style)
       (remove 'lines-tail whitespace-style))
  (whitespace-mode +1))

(defun my/org-bline-minor-mode--fini (&rest ignore)
  (my/org-bline-minor-mode 1)
  (remove-hook 'after-change-functions 'my/org-bline-minor-mode--fini t))

(add-hook 'org-mode-hook 'my/org-bline-minor-mode--init)
#+end_src
*** =cdlatex= mode
#+begin_src emacs-lisp
(use-package auctex
  :ensure t
  :defer t
  :config
  (load "auctex.el" nil t t)
  (load "preview-latex.el" nil t t))
(use-package cdlatex
  :ensure t
  :diminish org-cdlatex-mode
  :config
  (add-hook 'org-mode-hook #'turn-on-org-cdlatex)
  (setq cdlatex-math-modify-alist
             '((?B "\\mathbb" "\\textbb" t nil nil))))
#+end_src
** Appearance
The following allows you to specify =#+ATTR_ORG: :width 400= on an image
so that inline image previews can be resized
#+begin_src emacs-lisp
(setq org-image-actual-width nil)
#+end_src
** Org Babel
*** Personal Library Of Babel
Load custom functions I would like to be available in all org buffers
#+begin_src emacs-lisp
(run-with-idle-timer
 2 nil
 (lambda () (org-babel-lob-ingest (expand-file-name "lob.org" init-dir))))
#+end_src

*** =ob-ipython=
[[https://github.com/gregsexton/ob-ipython][Docs]]. Might consider switching to [[https://www.youtube.com/watch?v=dMira3QsUdg][scimax]] if I used it more
extensively.

To use =ob-ipython= use need =:session= argument to header of all src
blocks, also the src type is =ipython=. You can use =M-x
ob-ipython-inspect= to get documentation for the thing at point (in a
src block). You can also oepn a REPL connected to the current kernel
by running =C-c C-v C-z=.
#+begin_src emacs-lisp
(if (executable-find "jupyter")
    (use-package ob-ipython
      :ensure t
      :pin melpa
      :config
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((ipython . t)))))
#+end_src
** Tracking TODOs and Agenda
Log =TODO= state transitions in the =LOGBOOK= property drawer by default.
#+begin_src emacs-lisp
(setq org-log-into-drawer t)
#+end_src
*** Marking tasks done some time in the past
Sometimes I forget to mark a repeating task done the day I do it, so
when I mark them done the =LAST_REPEAT= and next scheduled time are
automatically entered as being relative to a later day than they
should. This function prompts for a date, and marks the task as done
on that day

#+begin_src emacs-lisp
(defmacro with-curtime (curtime &rest body)
  `(cl-letf* (((symbol-function 'current-time) (lambda () ,curtime))
              ((symbol-function 'fts) (symbol-function 'format-time-string))
              ((symbol-function 'org-today) (lambda () (time-to-days ,curtime)))
              ((symbol-function 'format-time-string)
               (lambda (fmt &optional tm z)
                 (apply 'fts (list fmt (or tm ,curtime) z)))))
     (progn ,@body)))

(defun mark-done-on-day ()
  (interactive)
  (let ((curtime (org-read-date t t)))
    ;; (org-read-date) seems to only return high/low seconds, not usec/psec
    ;; as is also returned by (current-time)
    (if (eq 2 (length curtime))
        (setq curtime `(,@curtime 0 0)))
    (with-curtime curtime (org-todo 'done))))
#+end_src
** =org-pomodoro=
Trying out =org-pomodoro= mode
#+begin_src emacs-lisp
(use-package org-pomodoro
  :ensure t
  :config
  (setq org-pomodoro-audio-player "paplay")
  (setq org-pomodoro-short-break-sound-args "--volume 40000")
  (setq org-pomodoro-long-break-sound-args "--volume 40000")
  (setq org-pomodoro-finished-sound-args "--volume 40000"))
#+end_src

** Export

*** Pretty source blocks
Fontify source blocks in org buffer, and include the appropriate CSS
in HTML export
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
;; From http://emacs.stackexchange.com/q/3374
(defun my/org-inline-css-hook (exporter)
  "Insert custom inline css to set the
background of code blocks to that of whatever theme I'm using"
  (when (eq exporter 'html)
    (let* ((my-pre-bg (face-background 'default))
           (my-pre-fg (face-foreground 'default)))
      (setq
       org-html-head-extra
       (concat
        org-html-head-extra
        (format "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
                my-pre-bg my-pre-fg))))))
(add-hook 'org-export-before-processing-hook 'my/org-inline-css-hook)

;; Needed to fontify src blocks
(use-package htmlize :ensure t)
#+end_src

*** Smart Quotes
This feature came to Org in version 8, and it's crazy to me that it's
not the default. It lets you type "normal quotes" in the org buffer,
as opposed to =``this latex stuff''=, and will transform them on
export so that your HTML/text output looks nice /and/ your latex
export looks nice!

#+begin_src emacs-lisp
(setq org-export-with-smart-quotes t)
#+end_src

*** Latex quote blocks
#+begin_src emacs-lisp
(defun org-latex-quote-block (quote-block contents info)
  "Transcode a QUOTE-BLOCK element from Org to LaTeX.
CONTENTS holds the contents of the block.  INFO is a plist
holding contextual information."
  (org-latex--wrap-label
   quote-block (format "\\begin{quote}\n``%s''\\end{quote}" contents) info))
#+end_src

** Open URLs in Firefox
#+begin_src emacs-lisp
(setq org-file-apps
    (quote
      ((auto-mode . emacs)
      ("\\.mm\\'" . default)
      ("\\.x?html?\\'" . "firefox %s")
      ("\\.pdf\\'" . default))))
#+end_src
** PDF Tools
Learned about using pdf-tools from [[https://www.youtube.com/watch?v=LFO2UbzbZhA][this]] YT video.
#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :mode "\\.pdf\\'"
  :config
  ;; attempt to install without prompting, but don't try to install
  ;; system package dependencies
  (pdf-tools-install t t))

;; Setup pdf:: link scheme in org mode
(use-package org-pdftools :ensure t
  :after pdf-tools
  :config
  (org-pdftools-setup-link))
#+end_src

** Org Babel Rust

#+begin_src emacs-lisp
(use-package ob-rust :ensure t)
#+end_src

* C/C++ Modes
** Editing
*** Format with =clang-format=
Though we enabled general use of EditorConfig [[#general-editorconfig][above]], =clang-format= is
superior for C/C++ code. So, we'll add a mode hook that will use it
for indenting/formatting a region when =.clang-format= file is
detected, and we have a =clang-format= executable.
#+begin_src emacs-lisp
(defvar clang-format-executable "clang-format")

(defun my/use-clang-format ()
  (and (buffer-file-name)
       (locate-dominating-file (buffer-file-name) ".clang-format")
       (executable-find clang-format-executable)))

(defun my/maybe-set-clang-indent-region ()
  (when (my/use-clang-format)
    (setq-local indent-region-function #'clang-format-region)
    (add-hook 'before-save-hook #'clang-format-buffer nil t)))

(use-package clang-format
  :ensure t
  :config
  ;; Cant just set indent-region-function in c-mode-common-hook because
  ;; it is overwritten in {c,c++}-mode-hooks
  (add-hook 'c-mode-hook #'my/maybe-set-clang-indent-region)
  (add-hook 'c++-mode-hook #'my/maybe-set-clang-indent-region nil t))
#+end_src
*** =gtags=

#+begin_src emacs-lisp
(use-package gtags
  :load-path ("/usr/share/global"
              "/usr/share/gtags"
              "/usr/local/share/global"
              "/usr/local/share/gtags")
  :diminish gtags-mode)
(use-package ggtags
  :ensure t
  :diminish ggtags-mode)
#+end_src

*** Use =electric-pair-mode=
This is great for auto-inserting closing parentheses, doing the right
thing when I press "Enter" on the opening brace of a function
definition (thanks to =electric-indent-mode=), etc.
#+begin_src emacs-lisp
(defun my/turn-on-local-electric-pair ()
  (electric-pair-local-mode +1))

(add-hook 'c-mode-hook #'my/turn-on-local-electric-pair)
(add-hook 'c++-mode-hook #'my/turn-on-local-electric-pair)
#+end_src

*** =cmake-mode=
#+begin_src emacs-lisp
(use-package cmake-mode :ensure t)
#+end_src

*** Open .h files in C++ mode by default
If in a plain old C project and want =.h= files to be opened in
=c-mode= add the following to =dir-locals.el= to achieve this (as
described [[https://stackoverflow.com/a/6912415][here]]): =((c++-mode . ((mode . c))))=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+end_src


*** Disable =auto-fill-mode= except for comments

#+begin_src emacs-lisp
(add-hook 'c-mode-common-hook #'comment-auto-fill)
#+end_src
* Rust Mode
#+begin_src emacs-lisp
(use-package rust-mode
  :ensure t
  :hook (rust-mode . rust-enable-format-on-save))
#+end_src
* Dired mode
*** =dired-x=
#+begin_src emacs-lisp
(use-package dired-x
  :bind ("C-x C-j" . dired-jump))
#+end_src

*** Jump to dired buffer in eshell
#+begin_src emacs-lisp
(defun my/dired-open-in-eshell ()
  (interactive)
  (let ((cwd default-directory))
    (call-interactively #'eshell)
    (eshell/cd cwd)
    ;; if eshell buffer is already open, then the prompt doesn't seem
    ;; to be updating. E.g. if eshell was at "~ $" and we use this
    ;; function to cd to /some/dir, the prompt stays at "~ $". We can
    ;; force an update (on a new line) by sending an empty line input
    ;; to the shell. Make sure we clear any input that might already
    ;; by in eshell buffer so we don't execute unexpected commands.
    (eshell-kill-input)
    (eshell-send-input)))

(use-package dired
  :bind (:map dired-mode-map
              ("E" . my/dired-open-in-eshell))
  :config
  ;; Get human-readable sizes in dired
  (setq dired-listing-switches "-alh"))
#+end_src

* Haskell Mode
#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
  :mode (("\\.hs\\'" . haskell-mode)
         ("\\.lhs\\'" . haskell-mode))
  :config
  (add-hook 'haskell-cabal-mode-hook
            (lambda ()
              (add-hook 'before-save-hook #'whitespace-cleanup t t))))

(defun my/config-haskell-buf ()
  (interactive-haskell-mode +1)
  (hindent-mode +1)
  (add-hook 'before-save-hook #'hindent-reformat-buffer t t))

(use-package hindent
  :ensure t
  :diminish hindent-mode
  :config
  (add-hook 'haskell-mode-hook #'my/config-haskell-buf))
#+end_src

* Python Mode
After installing the [[* Dependencies][dependencies]], we can use =Elpy=
#+begin_src emacs-lisp
(use-package elpy
  :ensure t
  :mode "\\.py\\'"
  :config
  (elpy-enable))
#+end_src

* Kotlin Mode
#+begin_src emacs-lisp
(use-package kotlin-mode :ensure t)
(use-package gradle-mode :ensure t)
#+end_src

* Web mode
#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :mode (("\\.jsx\\'" . web-mode)
         ("\\.tsx\\'" . web-mode)))
(use-package typescript-mode
  :ensure t
  :mode "\\.tsx?\\'")

(defun my/setup-tide-mode ()
  (tide-setup)
  (add-hook 'before-save-hook #'tide-format-before-save nil t))

(defun my/setup-tide-jsx-or-tsx ()
  (when (string-match-p "^jsx\\'\\|^tsx\\'"
                        (file-name-extension buffer-file-name))
    (my/setup-tide-mode)
    (setq-local web-mode-enable-auto-quoting nil)))

(use-package tide
  :ensure t
  :after (typescript-mode company flycheck web-mode)
  :hook ((typescript-mode . my/setup-tide-mode)
         (web-mode . my/setup-tide-jsx-or-tsx)))
#+end_src
* Misc Modes
** Markdown
#+srcname: name
#+begin_src emacs-lisp
(use-package markdown-mode :ensure t :mode "\\.md\\'")
#+end_src
** =glsl-mode=
#+begin_src emacs-lisp
(use-package glsl-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.glsl\\'" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.vert\\'" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.frag\\'" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.geom\\'" . glsl-mode)))
#+end_src
** =yaml-mode=
#+begin_src emacs-lisp
(use-package yaml-mode :ensure t :mode "\\.yaml")
#+end_src

** =re-builder=
Set the default =re-builder= syntax to =string= so I can save 1 billion
press/release cycles on my backslash key

#+begin_src emacs-lisp
(setq reb-re-syntax 'string)
#+end_src

** =nasm-mode=
#+begin_src emacs-lisp
(use-package nasm-mode
  :ensure t
  :mode "\\.nasm\\'")
#+end_src
** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode :ensure t)
#+end_src

** ERC
I use ZNC as an IRC bouncer, hosted on a Raspberry Pi that broadcasts
its hostname using multicast DNS (mDNS). The =erc= function uses
=open-network-stream=, which does not do well with mDNS names
(=blah.local=), so I define a wrapper that resolves these hostnames
using =avahi= before passing arguments along to =erc-tls=. Specify this as
the =znc-erc-ssl-connector= custom variable.
#+begin_src emacs-lisp
(use-package znc :defer t :ensure t)

(setq my/avresolve (executable-find "avahi-resolve-host-name"))

(defun my/resolve-mdns-name (host)
  (unless my/avresolve
    (error "avahi-resolve-host-name is required"))

  (with-temp-buffer
    (let* ((stderr-file (make-temp-file "avahi-resolve-stderr"))
           (ret (call-process my/avresolve
                              nil (list t stderr-file) nil "-4" host))
           (stdout (buffer-substring (point-min) (point-max)))
           (_ (insert-file-contents stderr-file nil nil nil t))
           (stderr (buffer-substring (point-min) (point-max))))
      (delete-file stderr-file)
      (when (or (not (equal 0 ret)) (> (length stderr) 0))
        (error (format "avahi-resolve failed on hostname \"%s\": %s" host stderr)))
      (cadr (split-string stdout nil t "\\s-\\+")))))

(require 'cl-lib)
(cl-defun my/erc-tls-connect-mdns
    (&rest args &key server &allow-other-keys)
  (require 'dash)
  (let* ((ip (my/resolve-mdns-name server))
         (i (seq-position args ':server))
         (args (-replace-at (1+ i) ip args)))
    (apply 'erc-tls args)))

(defun my/clear-erc-status-mode-line ()
  (interactive)
  (setq erc-modified-channels-alist '())
  (erc-modified-channels-display))

(use-package erc
  :config
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
  (add-hook 'erc-mode-hook (lambda ()
                             (erc-truncate-mode +1)
                             (erc-spelling-mode +1)
                             (diminish 'projectile-mode))))

(use-package erc-hl-nicks :ensure t)
;; ignore IRC buffers in helm buffer list (or any buffer that starts with '#'...)
(add-to-list 'helm-boring-buffer-regexp-list "\\`#")
(add-to-list 'helm-boring-buffer-regexp-list "\\`\\*ERC Status\\*\\'")
(dolist (network '("Freenode" "SFML" "Twitch" "QuakeNet"))
         (add-to-list 'helm-boring-buffer-regexp-list (format "\\`\\*irc-%s\\*\\'" network)))
#+end_src

*** =erc-status-sidebar=
A little module I wrote to show channel status in a sidebar

#+begin_src emacs-lisp
(use-package erc-status-sidebar
  :commands (erc-status-sidebar-toggle)
  :bind (:map erc-mode-map ("C-c C-s" . #'erc-status-sidebar-toggle)))

(defun my/erc-window-reuse-condition (buf-name action)
  (with-current-buffer buf-name
    (if (eq major-mode 'erc-mode)
        ;; Don't override an explicit action
        (not action))))

(add-to-list 'display-buffer-alist
             '(my/erc-window-reuse-condition .
               (display-buffer-reuse-mode-window
                (inhibit-switch-frame . t)
                (mode . erc-mode))))
#+end_src

* Misc config
Turn on =helm-top-poll-mode= so that =helm-top= auto-refreshes.

#+begin_src emacs-lisp
(helm-top-poll-mode 1)
#+end_src
