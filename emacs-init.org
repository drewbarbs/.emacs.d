#+TITLE: Emacs Configuration
#+AUTHOR: Drew Barbarello

* About
My emacs configuration inspired by [[http://endlessparentheses.com/init-org-Without-org-mode.html][this]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][this]].

* Dependencies
The packages configured by this file require the following to be used
to their fullest extent:
- Emacs >= 24.5 (for magit)
- Git >= 1.9.4 (for magit)
- rtags (used by cmake-ide)
- GNU Global >= (for gtags, used as a fallback if rtags hasn't
  indexed a project)
- =clang-format=
- Python + IPython >= 5 + Jupyter >= 1.0 for [[https://github.com/gregsexton/ob-ipython][ob-ipython]]

* Personal
#+begin_src emacs-lisp
(setq user-full-name "Andrew Barbarello"
      user-email-address "andrew.barbarello@outlook.com")
#+end_src

* Initialization

** Environment
#+begin_src emacs-lisp
(defvar current-user
      (getenv
       (if (equal system-type 'windows-nt) "USERNAME" "USER")))

;; equivalent of prelude-dir
(defvar init-dir user-emacs-directory
  "The root dir of the Emacs configuration.")

(add-to-list 'load-path (expand-file-name "misc" init-dir))
#+end_src

** Package archives
I configure the list of package archives to pull from in [[file:init.el][=init.el=]],
because Emacs 25 insisted on sticking a =(package-initialize)= call in
the head of that file.

** =use-package=
Inspired by [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][this]] post, using =use-package= to ensure packages are
installed and initialize them lazily.

=use-package= can integrate with =diminish= mode to hide minor modes from
the command line. =diminish= is [[https://github.com/jwiegley/use-package/commit/2c345ccc0eb4f2f3e26fe186d3f71f2b1b87b922][now]] an optional dependency of
=use-package=, so we'll go ahead and install it ourselves.

#+begin_src emacs-lisp
;; bootstrap `use-package', at the same time ensure we install org mode
;; from elpa
(unless (and (package-installed-p 'use-package)
             (package-installed-p 'diminish))
  (package-refresh-contents)
  (package-install 'use-package)
  (package-install 'diminish)
  (package-install-from-archive
   (car (alist-get 'org package-archive-contents))))
#+end_src

** =auto-compile=
Package to ensure previously byte-compiled files never shadow changes
in the corresponding source (=.el=) file.
#+begin_src emacs-lisp
(require 'use-package)
(use-package auto-compile
  :ensure t
  :init (setq load-prefer-newer t)
  :config (auto-compile-on-load-mode))
#+end_src

** =custom-file=
The place where =custom-set-variables= decisions are persisted.
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom-settings.el" init-dir))
(load custom-file t)
#+end_src

** Startup buffer
Show =*scratch*= buffer on startup, rather than splash screen.
#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
#+end_src

* Global

** Editing
Universal editing configuration: how to handle whitespace, etc.
Largely lifted from =prelude-editor.el=.
*** Whitespace
#+begin_src emacs-lisp
;; Death to the tabs!  However, tabs historically indent to the next
;; 8-character offset; specifying anything else will cause *mass*
;; confusion, as it will change the appearance of every existing file.
;; In some cases (python), even worse -- it will change the semantics
;; (meaning) of the program.
;;
;; Emacs modes typically provide a standard means to change the
;; indentation width -- eg. c-basic-offset: use that to adjust your
;; personal indentation width, while maintaining the style (and
;; meaning) of any files you load.
(setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
(setq-default tab-width 8)            ;; but maintain correct appearance

;; Newline at end of file
(setq require-final-newline t)
#+end_src

**** =whitespace-mode=
Clean whitespace on save, highlight whitespace in buffers. A subtle
bit here is the =advice-add= call that runs =whitespace-cleanup= on
"save" in =Org Src= buffers. Saving in such a buffer persists the
code block change back to the parent Org file, but it /doesn't/ run
=before-save-hook=, so the expected behavior that whitespace is
cleaned on =C-x C-s= doesn't occur unless you add it as function advice.
#+begin_src emacs-lisp
(defun my/enable-whitespace ()
  "Enable `whitespace-mode' and invoke `whitespace-cleanup' on file save."
  (add-hook 'before-save-hook #'whitespace-cleanup nil t)
  ;; Run whitespace-cleanup on an Org Src buffer on "save" back to the parent file
  (advice-add 'org-edit-src-save :before #'whitespace-cleanup)
  (whitespace-mode +1))

;; In some programming modes, I want more wiggle room before line length warning
(defun my/bump-line-len ()
  (setq whitespace-line-column 110))

(use-package whitespace
  :diminish whitespace-mode
  :config
  (setq whitespace-line-column 80)
  (setq whitespace-style '(face tabs empty trailing lines-tail))
  (add-hook 'text-mode-hook #'my/enable-whitespace)
  (add-hook 'prog-mode-hook #'my/enable-whitespace)
  (add-hook 'python-mode-hook #'my/bump-line-len))
#+end_src

*** Matching pairs (=smartparens-mode= and more)

The following block defines some keymappings for wrapping the active
region with a character (taken from Prelude), it requires =smartparens-mode=.

#+begin_src emacs-lisp
(defun prelude-wrap-with (s)
  "Create a wrapper function for smartparens using S."
  `(lambda (&optional arg)
     (interactive "P")
     (sp-wrap-with-pair ,s)))

(defun partial-map-add (key fun)
  "Given a keymapping KEY -> FUN, return a function that takes a
keymap and adds the given mapping"
  `(lambda (keymap)
     (define-key keymap ,key ,fun)))

(setq my/wrap-mappings
      (mapcar (lambda (pair) (partial-map-add (car pair) (cdr pair)))
        '(((kbd "M-\"") . (prelude-wrap-with "\""))
          ((kbd "M-(") . (prelude-wrap-with "("))
          ((kbd "M-[") . (prelude-wrap-with "[")))))

(defun my/add-wrap-mappings (map)
  (mapc (lambda (mapping) (funcall mapping map)) my/wrap-mappings))

(my/add-wrap-mappings prog-mode-map)
(add-hook 'c-initialization-hook
          (lambda () (my/add-wrap-mappings c-mode-base-map)))
#+end_src

Here, we setup =smartparens= to show matching pairs and install its
=paredit=-style bindings.

#+begin_src emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :config
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)
  (setq sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1))
#+end_src

*** Typing replaces selection
Another bit of config from Prelude that I didn't realize I needed
until I ran Emacs without it. With this setting, typing replaces an
active selection, whereas the default behavior is that text is just
inserted at point regardless of the selection.

#+begin_src emacs-lisp
(delete-selection-mode +1)
#+end_src

*** =auto-fill-mode=
For programming modes, define the function =comment-auto-fill= to
disable auto-fill except for on comments. Taken from [[https://www.emacswiki.org/emacs/AutoFillMode][here]].

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'turn-on-auto-fill)
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(diminish 'auto-fill-function)
#+end_src

*** Expand at point

**** =company-mode=
#+begin_src emacs-lisp
(use-package company
  :ensure t
  :init (global-company-mode)
  :config
  (setq company-tooltip-align-annotations t)
  ;; Easy navigation to candidates with M-<n>
  (setq company-show-numbers t)
  (setq company-dabbrev-downcase nil)
  (add-hook 'c-initialization-hook
            (lambda ()
              (define-key c-mode-base-map (kbd "M-/") #'company-complete)))
  (define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
  (define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)
  :diminish company-mode)
#+end_src

**** =company-quickhelp=
Show a documentation popup for company completion candidates

#+begin_src emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config
  (company-quickhelp-mode 1))
#+end_src


**** =hippie-expand=
Setup =hippie-expand=, which completes the word before point using one
of a variety of sources. Another bit of config taken verbatim from
Prelude

#+begin_src emacs-lisp
;; hippie expand is dabbrev expand on steroids
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))
(global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

**** =abbrev=
Enable =abbrev= for =text-mode= buffers.

#+begin_src emacs-lisp
(setq abbrev-file-name (expand-file-name "abbrev_defs" init-dir))
(add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
(diminish 'abbrev-mode)
#+end_src

Check out the manual for =abbrev-mode= [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs][here]]. In brief, the important
keybindings are:

- =C-x a g= :: Add global abbreviation for the word before point.
               Can call with a numeric prefix argument \(n\) to
               specify the number of words prior to point to define
               the abbreviation for.
- =C-x a l= :: Define an abbreviation as above, but that only applies
               to the current major mode.
- =C-x a i g= :: Use word before point as an abbreviation for a phrase
                 you define in the minibuffer.
- =M-x kill-all-abbrevs= :: Discard all abbrev definitions.

In order to type a prefix to an abbreviation (text that precedes the
expanded abbreviation without whitespace in between): type the prefix,
then type =M-=' followed by the abbreviation.

To type an abbreviation /without/ having it expand, type =C-q <SPC>=.

*** General indentation/formatting
Setup indentation/formatting bindings that apply in (nearly) any major
mode.

First, setup =<TAB>= to first indent the current line, then if the
line is already indented, complete the thing at point.
#+begin_src emacs-lisp
(setq tab-always-indent 'complete)
#+end_src

The next bit of code from Prelude makes =indent-region= and =untabify=
act on the whole buffer if called without an active region.

#+begin_src emacs-lisp
(defmacro with-region-or-buffer (func)
  "When called with no active region, call FUNC on current buffer."
  `(defadvice ,func (before with-region-or-buffer activate compile)
     (interactive
      (if mark-active
          (list (region-beginning) (region-end))
        (list (point-min) (point-max))))))

(use-package tabify
  :config
  (with-region-or-buffer indent-region)
  (with-region-or-buffer untabify))
#+end_src

*** EditorConfig
    :PROPERTIES:
    :CUSTOM_ID: general-editorconfig
    :END:

#+begin_src emacs-lisp
(use-package editorconfig
  :ensure t
  :diminish editorconfig-mode
  :init
  (add-hook 'prog-mode-hook (editorconfig-mode 1))
  (add-hook 'text-mode-hook (editorconfig-mode 1)))
#+end_src

*** =flycheck=
#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode))
#+end_src

** Appearance

*** Theme
Using leuven, along with powerline

#+begin_src emacs-lisp
(setq column-number-mode t)

(use-package leuven-theme
  :ensure t
  :pin melpa
  :config (load-theme 'leuven :no-confirm))

(use-package powerline
  :ensure t
  :config
  (powerline-default-theme))
#+end_src

Leuven theme doesn't make overdue agenda items sufficiently prominent

#+begin_src emacs-lisp
(eval-after-load 'org
  (set-face-attribute 'org-scheduled-previously nil
                    :foreground "red" :weight 'bold))
#+end_src

*** Font
Set font size to 12 point (height value is in 1/10 pt)
#+begin_src emacs-lisp
(set-face-attribute 'default nil :height 120)
(defun my/have-font (font)
  (member font (font-family-list)))

(defun my/setup-fonts (frame)
  (when frame
    (select-frame frame))
  (let ((ft
         (cond ((my/have-font "Source Sans Pro") '(:font "Source Sans Pro"))
               ((my/have-font "Lucida Grande") '(:font "Lucida Grande"))
               ((my/have-font "Sans Serif") '(:family "Sans Serif")))))
    ;; set the variable-pitch face to use font we found
    (eval `(set-face-attribute 'variable-pitch nil ,@ft)))
  (when (my/have-font "Source Code Pro")
    (set-face-attribute 'default nil :font "Source Code Pro" :height 120)))
(add-hook 'after-make-frame-functions #'my/setup-fonts)
(my/setup-fonts nil)

(defun my/variable-pitch-hook-set-cursor ()
  "Set the `cursor-type' to `bar' when entering variable-pitch mode, and
restore the original when leaving."
  (if (and buffer-face-mode
           (eq buffer-face-mode-face 'variable-pitch))
      (progn
        (setq-local buf-old-cursor-type cursor-type)
        (setq cursor-type 'bar))
    (setq cursor-type
          (if (boundp 'buf-old-cursor-type) buf-old-cursor-type))))
(add-hook 'buffer-face-mode-hook #'my/variable-pitch-hook-set-cursor)
#+end_src

#+begin_src emacs-lisp
;; Font size
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(diminish 'text-scale-mode)
#+end_src

*** Disable Window Chrome
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

*** Make =point= easier to find
Animate the current line when making point jump/activating point in
another window
#+begin_src emacs-lisp
;; show the cursor when moving after big movements in the window
(use-package beacon
  :diminish 'beacon-mode
  :ensure t
  :config (beacon-mode +1))
#+end_src

** Behavior
*** Ask for confirmation before quitting
#+begin_src emacs-lisp
(defun my/confirm-kill-eclient ()
  (interactive)
  (if (yes-or-no-p "Are you sure you want to exit Emacs? ")
      (save-buffers-kill-terminal)))
(global-set-key (kbd "C-x C-c") #'my/confirm-kill-eclient)
#+end_src

*** Auto refresh buffer when associated file changes
#+srcname: name
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(diminish 'auto-revert-mode)
#+end_src

*** Change "yes or no" to "y or n"
Type out the full strings "yes" and "no"? Ain't nobody got time for that.
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Disambiguate buffers with the same name
#+begin_src emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)     ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+end_src

*** Undo tree
=C-x u= on steroids: browse history of edits (undo and redo).
#+begin_src emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :ensure t
  :config
  ;; autosave the undo-tree history
  (setq undo-tree-history-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq undo-tree-auto-save-history t)
  (global-undo-tree-mode))
#+end_src

*** =anzu=
Use =anzu= to improve isearch/query-replace by highlighting
matches/showing a preview of the replacement as you type

#+begin_src emacs-lisp
(use-package anzu
  :ensure t
  :diminish anzu-mode
  :bind (("M-%" . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp))
  :config
  (global-anzu-mode))
#+end_src

*** Sentences end with a single space
Saw this in Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][config]], and adopting it here. Allows
=forward-sentence= (=M-e=) and =backward-sentence= (=M-a=) to work as
expected.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

*** Prefer vertical splits
From [[http://stackoverflow.com/a/25587333/756104][this]] stack overflow answer, opens a new window with a vertical
split if there's sufficient room available, otherwise uses a
horizontal split.
#+begin_src emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 200)
#+end_src

*** Transpose Windows
Bind =C-c y= to transpose windows (a vertical split becomes a
horizontal one and vice versa). =C-c f= will swap buffers across $y$
axis, =C-c F= will swap buffers across $x$ axis.
#+begin_src emacs-lisp
(use-package transpose-frame
  :ensure t
  :bind (("C-c y" . transpose-frame)
         ("C-c f" . flop-frame)
         ("C-c F" . flip-frame)))
#+end_src


*** Backups/Persistence
Pretty much all this stuff is copied verbatim from Prelude. It gets
the =backup~= files out of the way, remembers where you last left in a
file, remembers minibuffer history, etc.

#+begin_src emacs-lisp
(defvar my/savefile-dir (expand-file-name "savefile" init-dir)
  "This folder stores all the automatically generated save/history-files.")

(unless (file-exists-p my/savefile-dir)
  (make-directory my/savefile-dir))
#+end_src

Store all backup files in temp directory, so as to not pollute the
project directory.
#+begin_src emacs-lisp
;; store all backup and autosave files in the tmp dir
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

*** Don't ring bell on macOS
That behavior is annoying
#+begin_src emacs-lisp
(setq ring-bell-function #'ignore)
#+end_src

** Navigation
*** =helm=
An all-encompassing completion package. See [[https://github.com/emacs-helm/helm/wiki#helm-interaction-model][here]] for
philosophy/essential keybindings.

To "helm" a command, use the =helm-command-prefix-key=: =C-x c=. E.g.
=C-x c M-x= runs =helm-M-x=.

#+begin_src emacs-lisp
(use-package helm
  :diminish helm-mode
  :init
  (progn
    (use-package helm-config :ensure helm)
    (helm-mode 1))
  :bind (("M-x" . helm-M-x)
         ("M-s o" . helm-occur)
         ("C-h a" . helm-apropos)
         ("C-x r b" . helm-filtered-bookmarks)
         ("C-x b" . helm-buffers-list)
         ("M-y" . helm-show-kill-ring)
         ("C-x C-b" . helm-mini)
         ("C-x C-f" . helm-find-files))
  :config
  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "M-r") #'helm-eshell-history))))
#+end_src

Add =helm-swoop=, which is like a souped-up =occur=. It moves the
cursor in the original buffer around with the selected swoop match,
can show a configurable number of context lines (prefix argument),
can search across multiple buffers, etc.

While searching with =isearch=, you can launch =helm-swoop= with the
current search term by pressing =M-i=.

#+begin_src emacs-lisp
(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-swoop)
         ("C-x M-i" . helm-multi-swoop-all)))
#+end_src

**** Find
Use =helm-find= to accomplish =find . | grep=-like functionality. In
=helm-find-files= (=C-x C-f=), type =C-c /= to recursively find files
in the selected directory with names containing the given pattern.

*** Jump to char with =avy=
Use =avy=, based on =ace-jump-mode= and =vim-easymotion=.

- Jump to a character using =C-:=
- Jump to a character (after entering two characters) using =C=' (does
  not work in org mode, because this is instead bound to org-cycle-agenda-files
- Jump to a line with =M-g f=
- Jump to a word with =M-g w= (like =avy-goto-char=, but only matches
  that character at the beginning of a word.

#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind (("C-:" . avy-goto-char)
         ("C-'" . avy-goto-char-2)
         ("M-g '" . avy-goto-char-2)
         ("M-g l" . avy-goto-line)
         ("M-g w" . avy-goto-word-1)))
#+end_src


**** =recentf-mode=
I use =recentf-open-files= all the time.
#+begin_src emacs-lisp
(defun prelude-recentf-exclude-p (file)
  "A predicate to decide whether to exclude FILE from recentf."
  (let ((file-dir (file-truename (file-name-directory file))))
    (-any-p (lambda (dir)
              (string-prefix-p dir file-dir))
            (mapcar 'file-truename (list my/savefile-dir package-user-dir)))))

;; Taken from https://gist.github.com/masutaka/1325654/09b1cc94258f63e251cf74806499ce92225edd26
;; to avoid extraneous writes to the minibuffer
(defvar my/recentf-list-prev nil)
(defun my/setup-recentf-advice ()
  (defadvice recentf-save-list
      (around no-message activate)
    "If `recentf-list' and previous recentf-list are equal,
do nothing. And suppress the output from `message' and
`write-file' to minibuffer (still shows up in *Messages* buffer)."
    (unless (equal recentf-list my/recentf-list-prev)
      (let ((inhibit-message t))
        ad-do-it
        (setq my/recentf-list-prev recentf-list)))))

(use-package recentf
  :bind ("C-x C-r" . helm-recentf)
  :config
  (my/setup-recentf-advice)

  (setq recentf-save-file (expand-file-name "recentf" my/savefile-dir)
        recentf-max-saved-items 500
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)
  (add-to-list 'recentf-exclude 'prelude-recentf-exclude-p)
  (add-to-list 'recentf-exclude "/recentf\\'")
  (recentf-mode +1)
  (run-at-time nil 10 'recentf-save-list))
#+end_src

**** Save place in file
#+begin_src emacs-lisp
(use-package saveplace
  :ensure t
  :config
  (setq save-place-file (expand-file-name "saveplace" my/savefile-dir))
  ;; activate save-place for all buffers
  (setq-default save-place t))
#+end_src


**** Save minibuffer history
From Prelude, configure =savehist= to store the last few commands run
in the minibuffer, which persists across runs of emacs.
#+begin_src emacs-lisp
(use-package savehist
  :ensure t
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        savehist-file (expand-file-name "savehist" my/savefile-dir))
  (savehist-mode +1))
#+end_src

*** =projectile=
#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-global-mode)
  ;; workaround for https://github.com/bbatsov/projectile/issues/1183
  (setq projectile-mode-line
        '(:eval (format " Projectile[%s]"
                        (projectile-project-name)))))
#+end_src

#+begin_src emacs-lisp
(use-package helm-projectile
  :ensure t
  :config
  (helm-projectile-on))
#+end_src

*** =google-this=
#+begin_src emacs-lisp
(use-package google-this
  :ensure t
  :diminish google-this-mode
  :config
  (google-this-mode 1))
#+end_src

** Snippets
Fetch yasnippet, add the =other-snippets= directory to the path (where
I pull in additional snippets via git submodules).
#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :ensure t
  :init
  (setq yas-snippet-dirs
        `(,(expand-file-name "other-snippets" init-dir)
          ,(expand-file-name "snippets" init-dir)))
  (yas-global-mode 1)
  (yas-reload-all))
#+end_src

** Git

*** =magit-mode=
#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status))
#+end_src

*** Highlight uncommitted changes
#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :pin melpa
  :config
  (global-diff-hl-mode +1)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))
#+end_src

*** Expand outline when diffing
Useful for diffing org mode
#+begin_src emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+end_src

** =flyspell-mode=
Flyspell config, appropriate from Prelude.
#+begin_src emacs-lisp
(defun prelude-enable-flyspell ()
  "Enable command `flyspell-mode' if ispell program is available"
  (when (executable-find ispell-program-name)
    (flyspell-mode +1)
    ;; enable the flyspell word correction dialog when there's a window system
    (if window-system
        (global-set-key (kbd "M-$") 'flyspell-correct-word-before-point))))

(use-package flyspell
  :ensure t
  :diminish flyspell-mode
  :config
  (setq ispell-program-name "aspell" ; use aspell instead of ispell
        ispell-extra-args '("--sug-mode=ultra"))
  (add-hook 'text-mode-hook #'prelude-enable-flyspell))
#+end_src
** =devhelp=
#+begin_src emacs-lisp
(setq my/devhelp-path (executable-find "devhelp"))
;; adapted from https://git.gnome.org/browse/devhelp/tree/misc/devhelp.el
(defun my/devhelp-word-at-point ()
  "Searches for the current word in devhelp, if available"
  (interactive)
  (if (not my/devhelp-path)
      (message "devhelp executable could not be located")
    (start-process-shell-command "devhelp" nil
                                 (mapconcat #'identity (list my/devhelp-path "-s" (current-word)) " "))
    (set-process-query-on-exit-flag (get-process "devhelp") nil)))
(global-set-key [f7] #'my/devhelp-word-at-point)
#+end_src
* Eshell
#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook
          (lambda ()
            (add-to-list 'eshell-visual-commands "pacman")
            (add-to-list 'eshell-visual-commands "pacaur")
            (add-to-list 'eshell-visual-subcommands '("git" "log" "diff" "show"))))
#+end_src
* Org Mode
** Global Bindings
#+begin_src emacs-lisp
(defun my/org-set-face ()
  (variable-pitch-mode +1)
  (diminish 'buffer-face-mode)
  (dolist (face '(org-block-begin-line
                  org-block-end-line
                  org-verbatim
                  org-code
                  org-block
                  font-lock-keyword-face))
    (set-face-attribute face nil :inherit 'fixed-pitch))
  (setq org-hide-emphasis-markers t))

(use-package mixed-pitch
  :ensure t
  :diminish mixed-pitch-mode
  :config
  (add-hook 'org-mode-hook #'mixed-pitch-mode))

(use-package org
  :pin org
  :ensure t
  :bind (("C-c l" . org-store-link)
         ("M-p" . org-metaup)
         ("M-n" . org-metadown))
  :config
  (add-hook 'org-mode-hook #'my/org-set-face)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (sh . t))))
(use-package org-agenda :bind ("C-c a" . org-agenda))
(use-package org-capture :bind ([f6] . org-capture))
#+end_src
*** Org-Ref
A very cool/helpful package to manage citations in org file/take notes
for citations.

#+begin_src emacs-lisp
(defun my/org-ref-bibliography-format (orig-format keyword desc format)
  (cond
   ((eq format 'md) "")
   (t (apply orig-format keyword desc format nil))))

(use-package org-ref
  :ensure t
  :config
  (advice-add #'org-ref-bibliography-format
              :around #'my/org-ref-bibliography-format)
  (require 'org-ref-citeproc)
  (defun orcp-collect-citations ()
    "Return a list of citation links in the document."
    (setq *orcp-citation-links*
          (cl-loop for link in (org-element-map
                                   (org-element-parse-buffer) 'link 'identity nil nil nil t)
                   if (-contains?
                       org-ref-cite-types
                       (org-element-property :type link))
                   collect link)))
  (defun orcp-url (entry)
    (orcp-get-entry-field "url" entry)))
#+end_src

** Authoring Settings
*** Don't try and insert blank lines before new headings
#+srcname: name
#+begin_src emacs-lisp
(setq org-blank-before-new-entry (assq-delete-all 'heading org-blank-before-new-entry))
(push '(heading . nil) org-blank-before-new-entry)
#+end_src
*** Source block indentation
Disable Org's default behavior of indenting code from a source block
with spaces after saving back to buffer from =org-edit-src-code= (C-c ')
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
(setq org-edit-src-preserve-indentation nil)
#+end_src

*** Allow ordered lists with letters
#+begin_src emacs-lisp
(setq org-list-allow-alphabetical t)
#+end_src

*** Whitespace mode
Fix whitespace mode's naive =lines-tail= highlighting, so that only
the /description text/ of org mode links counts against the
=whitespace-line-column= limit. Inspired by example at
[[https://www.emacswiki.org/emacs/HighlightLongLines]].

#+begin_src emacs-lisp
;; a font-lock-keyword for org-mode. highlights parts of lines that extend past
;; whitespace-line-column, assuming that only the *description* of org links are
;; visible (and hence, only the descriptions count against the line length limit)

(defun my/advance-to-col (startpos startcol stopcol)
  "Given a start position STARTPOS in the current buffer, the column count
at point STARTPOS (STARTCOL) and desired end column (STOPCOL), return the
position of character starting column (STOPCOL+1)"
  (let ((curpos startpos)
        (curcols startcol))
    (while (<= curcols stopcol)
      (setq curcols (+ curcols (char-width (char-after curpos))))
      (setq curpos (1+ curpos)))
    curpos))

(defun my/next-long-org-line (limit)
  "Return the next tuple (start end) of positions from current value of (point) to
be marked as entending past line length LIMIT."
  (catch 'done
    (while (< (line-beginning-position) limit)
      (beginning-of-line)
      (let ((curcols 0)
            (lim (min limit (line-end-position)))
            (curpos (point)))
        (while (re-search-forward org-bracket-link-analytic-regexp lim t)
          (let ((mstartcol (+ curcols
                              (string-width (buffer-substring
                                             (match-beginning 0) curpos))))
                labelwidth
                labelstart)
            (if (match-string 5)
                ;; link of the form [[proto:link][description]]
                (setq labelwidth (string-width (match-string 5))
                      labelstart (match-beginning 5))
              ;; link of the form [[proto:something]]
              (setq labelwidth (string-width (concat (match-string 1) (match-string 3)))
                    labelstart (match-beginning 1)))
            (when (>= mstartcol whitespace-line-column)
              ;; link starts after whitespace-line-column, wholesale mark everything
              ;; after whitespace-line-column
              (throw 'done (list (my/advance-to-col curpos curcols whitespace-line-column) lim)))
            (when (>= (+ mstartcol labelwidth) whitespace-line-column)
              ;; link starts before whitespace-line-column, but description (visible part)
              ;; extends past it
              (throw 'done (list (my/advance-to-col labelstart mstartcol whitespace-line-column) lim)))
            (setq curcols (+ mstartcol labelwidth)))
          (setq curpos (point)))
        ;; no org link match, see if line is just a long one
        (let ((advancecols (string-width (buffer-substring (point) (line-end-position)))))
          (when (>= (+ curcols advancecols) whitespace-line-column)
            (throw 'done (list (my/advance-to-col curpos curcols whitespace-line-column) lim)))))
      (if (< (1+ (line-end-position)) (point-max))
          (forward-line)
        (throw 'done nil)))))

(defun my/match-long-org (limit)
  (let ((match-range (my/next-long-org-line limit)))
    (when match-range
      (set-match-data match-range)
      (goto-char (1+ (cadr match-range))))
    ;; if we didn't find a match, match-range is nil, and this matcher is done
    match-range))

(setq my/org-bline-minor-mode-font-lock-keywords
      '((my/match-long-org 0 whitespace-line prepend)))

(define-minor-mode my/org-bline-minor-mode "Overlong lines can make you blined."
  nil nil nil
  (if my/org-bline-minor-mode
      (font-lock-add-keywords nil my/org-bline-minor-mode-font-lock-keywords t)
    (font-lock-remove-keywords nil my/org-bline-minor-mode-font-lock-keywords))
  (font-lock-mode 1))

(defun my/org-bline-minor-mode--insin ()
  (add-hook 'after-change-functions 'my/org-bline-minor-mode--uate nil t)
  ;; for debugging purposes, disable the JIT
  ;; (setq font-lock-support-mode nil)
  ;; (font-lock-mode -1)
  ;; (font-lock-mode 1)

  ;; get rid of the long line highlighting from whitespace-mode, we're doing
  ;; our own highlighting
  (whitespace-mode 0)
  (set (make-local-variable 'whitespace-style)
       (remove 'lines-tail whitespace-style))
  (whitespace-mode +1))

(defun my/org-bline-minor-mode--uate (&rest ignore)
  (my/org-bline-minor-mode 1)
  (remove-hook 'after-change-functions 'my/org-bline-minor-mode--uate t))

(add-hook 'org-mode-hook 'my/org-bline-minor-mode--insin)
#+end_src
*** =cdlatex= mode
#+begin_src emacs-lisp
(use-package auctex
  :ensure t
  :defer t
  :config
  (load "auctex.el" nil t t)
  (load "preview-latex.el" nil t t))
(use-package cdlatex
  :ensure t
  :diminish org-cdlatex-mode
  :config
  (add-hook 'org-mode-hook #'turn-on-org-cdlatex)
  (setq cdlatex-math-modify-alist
             '((?B "\\mathbb" "\\textbb" t nil nil))))
#+end_src
** Org Babel
*** Personal Library Of Babel
Load custom functions I would like to be available in all org buffers
#+begin_src emacs-lisp
(org-babel-lob-ingest (expand-file-name "lob.org" init-dir))
#+end_src

*** =ob-ipython=
From [[https://github.com/gregsexton/ob-ipython][here]].
#+begin_src emacs-lisp
(if (executable-find "jupyter")
    (use-package ob-ipython
      :ensure t
      :pin melpa
      :config
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((ipython . t)))))
#+end_src
** Tracking TODOs and Agenda
Log =TODO= state transitions in the =LOGBOOK= property drawer by default.
#+begin_src emacs-lisp
(setq org-log-into-drawer t)
#+end_src
** =org-pomodoro=
Trying out =org-pomodoro= mode
#+begin_src emacs-lisp
(use-package org-pomodoro
  :ensure t
  :init
  (setq org-pomodoro-audio-player "paplay")
  (setq org-pomodoro-short-break-sound-args "--volume 40000")
  (setq org-pomodoro-long-break-sound-args "--volume 40000")
  (setq org-pomodoro-finished-sound-args "--volume 40000"))
#+end_src

** Export

*** Pretty source blocks
Fontify source blocks in org buffer, and include the appropriate CSS
in HTML export
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
;; From http://emacs.stackexchange.com/q/3374
(defun my/org-inline-css-hook (exporter)
  "Insert custom inline css to set the
background of code blocks to that of whatever theme I'm using"
  (when (eq exporter 'html)
    (let* ((my-pre-bg (face-background 'default))
           (my-pre-fg (face-foreground 'default)))
      (setq
       org-html-head-extra
       (concat
        org-html-head-extra
        (format "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
                my-pre-bg my-pre-fg))))))
(add-hook 'org-export-before-processing-hook 'my/org-inline-css-hook)

;; Needed to fontify src blocks
(use-package htmlize :ensure t)
#+end_src

*** Smart Quotes
This feature came to Org in version 8, and it's crazy to me that it's
not the default. It lets you type "normal quotes" in the org buffer,
as opposed to =``this latex stuff''=, and will transform them on
export so that your HTML/text output looks nice /and/ your latex
export looks nice!

#+begin_src emacs-lisp
(setq org-export-with-smart-quotes t)
#+end_src

*** Latex quote blocks
#+begin_src emacs-lisp
(defun org-latex-quote-block (quote-block contents info)
  "Transcode a QUOTE-BLOCK element from Org to LaTeX.
CONTENTS holds the contents of the block.  INFO is a plist
holding contextual information."
  (org-latex--wrap-label
   quote-block (format "\\begin{quote}\n``%s''\\end{quote}" contents) info))
#+end_src

** Open URLs in Firefox
#+begin_src emacs-lisp
(setq org-file-apps
    (quote
      ((auto-mode . emacs)
      ("\\.mm\\'" . default)
      ("\\.x?html?\\'" . "firefox %s")
      ("\\.pdf\\'" . default))))
#+end_src
** PDF Tools
Learned about using pdf-tools from [[https://www.youtube.com/watch?v=LFO2UbzbZhA][this]] YT video.
#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  ;; attempt to install without prompting, but don't try to install
  ;; system package dependencies
  (pdf-tools-install t t))

;; Setup pdfview:: link scheme in org mode
(use-package org-pdfview :ensure t)
(eval-after-load 'org '(require 'org-pdfview))
;; Per org-pdfview suggestion, configure org-mode default to open pdfs
;; with pdfview
(add-to-list 'org-file-apps
             '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))))
#+end_src
* Blog
A setup for authoring blog posts using org mode, taken from [[http://endlessparentheses.com/how-i-blog-one-year-of-posts-in-a-single-org-file.html][Endless Parentheses]].
#+begin_src emacs-lisp
(defvar endless/blog-base-url "http://dbarbs.net/")
(defvar endless/blog-dir nil)

(add-to-list 'load-path (expand-file-name "ox-pelican-subtree" init-dir))
(require 'ox-pelican-subtree)
#+end_src

* C/C++ Modes
** Editing
*** Format with =clang-format=
Though we enabled general use of EditorConfig [[#general-editorconfig][above]], =clang-format= is
superior for C/C++ code. So, we'll add a mode hook that will use it
for indenting/formatting a region when =.clang-format= file is
detected, and we have a =clang-format= executable.
#+begin_src emacs-lisp
(defvar clang-format-executable "clang-format")

(defun my/use-clang-format ()
  (and (buffer-file-name)
       (locate-dominating-file (buffer-file-name) ".clang-format")
       (executable-find clang-format-executable)))

(defun my/maybe-set-clang-indent-region ()
  (when (my/use-clang-format)
    (setq-local indent-region-function #'clang-format-region)
    (add-hook 'before-save-hook #'clang-format-buffer nil t)))

(use-package clang-format
  :ensure t
  :config
  ;; Cant just set indent-region-function in c-mode-common-hook because
  ;; it is overwritten in {c,c++}-mode-hooks
  (add-hook 'c-mode-hook #'my/maybe-set-clang-indent-region)
  (add-hook 'c++-mode-hook #'my/maybe-set-clang-indent-region nil t))
#+end_src
*** Use =electric-pair-mode=
This is great for auto-inserting closing parentheses, doing the right
thing when I press "Enter" on the opening brace of a function
definition (thanks to =electric-indent-mode=), etc.
#+begin_src emacs-lisp
(defun my/turn-on-local-electric-pair ()
  (electric-pair-local-mode +1))

(add-hook 'c-mode-hook #'my/turn-on-local-electric-pair)
(add-hook 'c++-mode-hook #'my/turn-on-local-electric-pair)
#+end_src

*** =gtags= and =rtags=
Setup both =gtags= and =rtags=, along with some keybindings, where the
keys will fall back to =gtags= if =GTAGS= files are present /and/
RTags isn't running/hasn't indexed the project.

Note, if in a file where neither =GTAGS= exists, nor RTags is running,
then running, e.g. =M-.= will print the message "Can't seem to connect
to server. Is rdm running?"

#+begin_src emacs-lisp
(use-package gtags
  :load-path ("/usr/share/global"
              "/usr/share/gtags"
              "/usr/local/share/global"
              "/usr/local/share/gtags")
  :diminish gtags-mode)
(use-package ggtags
  :ensure t
  :diminish ggtags-mode)

(defun use-rtags (&optional useFileManager)
  (and (executable-find "rc")
       (cond ((not (gtags-get-rootpath)) t)
             ((and
               (not (eq major-mode 'c++-mode))
               (not (eq major-mode 'c-mode)))
              (rtags-has-filemanager))
             (useFileManager (rtags-has-filemanager))
             (t (and (rtags-is-running) (rtags-is-indexed))))))

(defun tags-pop-tab-mark ()
  (interactive)
  (call-interactively (if (use-rtags) 'rtags-location-stack-back 'pop-tag-mark)))

(defun tags-find-symbol-at-point (&optional prefix)
  (interactive "P")
  (if (or (not (use-rtags)) (and (not (rtags-find-symbol-at-point prefix)) rtags-last-request-not-indexed))
      (call-interactively 'ggtags-find-definition)))
(defun tags-find-references-at-point (&optional prefix)
  (interactive "P")
  (if (or (not (use-rtags)) (and (not (rtags-find-references-at-point prefix)) rtags-last-request-not-indexed))
      (call-interactively 'ggtags-find-reference)))
(defun tags-find-symbol ()
  (interactive)
  (call-interactively (if (use-rtags) 'rtags-find-symbol 'ggtags-find-definition)))
(defun tags-find-references ()
  (interactive)
  (call-interactively (if (use-rtags) 'rtags-find-references 'ggtags-find-reference)))
(defun tags-find-file ()
  (interactive)
  (call-interactively (if (use-rtags t) 'rtags-find-file 'gtags-find-file)))
(defun tags-imenu ()
  (interactive)
  (call-interactively (if (use-rtags t) 'rtags-imenu 'idomenu)))

(use-package rtags
  :ensure t
  ;; Need to load rtags eagerly, otherwise the cmake-ide {c,c++}-mode hooks will
  ;; fail to launch rdm, even if it's not running
  :demand t
  :init
  (setq rtags-completions-enabled t)
  :bind
  (:map c-mode-base-map
   ("M-*" . tags-pop-tab-mark)
   ("M-." . tags-find-symbol-at-point)
   ("M-," . tags-find-references-at-point)
   ("C-." . tags-find-symbol)
   ("C-," . tags-find-references)
   ("C-<" . rtags-find-virtuals-at-point)
   ("M-<left>" . rtags-location-stack-back)
   ("M-<right>" . rtags-location-stack-forward))
  :config
  (set-face-attribute 'rtags-argument-face nil :foreground "#ffffff"))
#+end_src
*** =cmake-mode=
#+begin_src emacs-lisp
(use-package cmake-mode :ensure t)
#+end_src

*** =cmake-ide=
#+begin_src emacs-lisp
(use-package cmake-ide
  :ensure t
  :config (require 'subr-x) (cmake-ide-setup))
#+end_src

*** Open .h files in C++ mode by default
If in a plain old C project and want =.h= files to be opened in
=c-mode= add the following to =dir-locals.el= to achieve this (as
described [[https://stackoverflow.com/a/6912415][here]]): =((c++-mode . ((mode . c))))=
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+end_src


*** Disable =auto-fill-mode= except for comments

#+begin_src emacs-lisp
(add-hook 'c-mode-common-hook #'comment-auto-fill)
#+end_src
* Haskell Mode
#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
  :mode (("\\.hs\\'" . haskell-mode)
         ("\\.lhs\\'" . haskell-mode)))
#+end_src

* Misc Modes
** Markdown
#+srcname: name
#+begin_src emacs-lisp
(use-package markdown-mode :ensure t :mode "\\.md\\'")
#+end_src
** =glsl-mode=
#+begin_src emacs-lisp
(use-package glsl-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.glsl\\'" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.vert\\'" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.frag\\'" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.geom\\'" . glsl-mode)))
#+end_src
** =yaml-mode=
#+begin_src emacs-lisp
(use-package yaml-mode :ensure t :mode "\\.yaml")
#+end_src

** ERC
I use ZNC as an IRC bouncer, hosted on a Raspberry Pi that broadcasts
its hostname using multicast DNS (mDNS). The =erc= function uses
=open-network-stream=, which does not do well with mDNS names
(=blah.local=), so I define a wrapper that resolves these hostnames
using =avahi= before passing arguments along to =erc-tls=. Specify this as
the =znc-erc-ssl-connector= custom variable.
#+begin_src emacs-lisp
(use-package znc :ensure t)

(setq my/avresolve (executable-find "avahi-resolve-host-name"))

(defun my/resolve-mdns-name (host)
  (unless my/avresolve
    (error "avahi-resolve-host-name is required"))

  (with-temp-buffer
    (let* ((stderr-file (make-temp-file "avahi-resolve-stderr"))
           (ret (call-process my/avresolve
                              nil (list t stderr-file) nil "-4" host))
           (stdout (buffer-substring (point-min) (point-max)))
           (_ (insert-file-contents stderr-file nil nil nil t))
           (stderr (buffer-substring (point-min) (point-max))))
      (delete-file stderr-file)
      (when (or (not (equal 0 ret)) (> (length stderr) 0))
        (error (format "avahi-resolve failed on hostname \"%s\": %s" host stderr)))
      (cadr (split-string stdout nil t "\\s-\\+")))))

(require 'cl-lib)
(cl-defun my/erc-tls-connect-mdns
    (&rest args &key server &allow-other-keys)
  (require 'dash)
  (let* ((ip (my/resolve-mdns-name server))
         (i (seq-position args ':server))
         (args (-replace-at (1+ i) ip args)))
    (apply 'erc-tls args)))

(defun my/clear-erc-status-mode-line ()
  (interactive)
  (setq erc-modified-channels-alist '())
  (erc-modified-channels-display))

(use-package erc
  :config
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
  (add-hook 'erc-mode-hook (lambda ()
                             (erc-truncate-mode +1)
                             (erc-spelling-mode +1)
                             (diminish 'projectile-mode))))

(use-package erc-hl-nicks :ensure t)
#+end_src

*** =erc-status-sidebar=
A little module I wrote to show channel status in a sidebar

#+begin_src emacs-lisp
(use-package erc-status-sidebar
  :ensure t
  :commands (erc-status-sidebar-toggle)
  :bind (:map erc-mode-map ("C-c C-s" . #'erc-status-sidebar-toggle)))
#+end_src

* Misc config
Turn on =helm-top-poll-mode= so that =helm-top= auto-refreshes.

#+begin_src emacs-lisp
(helm-top-poll-mode 1)
#+end_src
