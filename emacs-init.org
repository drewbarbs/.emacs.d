#+TITLE: Emacs Configuration
#+AUTHOR: Drew Barbarello

* About
My emacs configuration inspired by [[http://endlessparentheses.com/init-org-Without-org-mode.html][this]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][this]].

* Personal
#+begin_src emacs-lisp
(setq user-full-name "Andrew Barbarello"
      user-email-address "andrew.barbarello@outlook.com")
#+end_src

* Initialization

** Environment
#+begin_src emacs-lisp
(defvar current-user
      (getenv
       (if (equal system-type 'windows-nt) "USERNAME" "USER")))

;; equivalent of prelude-dir
(defvar init-dir user-emacs-directory
  "The root dir of the Emacs configuration.")
#+end_src

** Package archives
#+begin_src emacs-lisp
(require 'package)
(setq my/package-archives '(("melpa" . "https://melpa.org/packages/")
                            ("org" . "http://orgmode.org/elpa/")))
(mapc (lambda (archive)
        (let ((id (car archive))
              (location (cdr archive)))
          (unless (assoc-default id package-archives)
            (add-to-list 'package-archives archive t)))) my/package-archives)
;; setup load path
(package-initialize)
(setq package-enable-at-startup nil)
#+end_src
We are manually calling =package-initialize=, so we set
=package-enable-at-startup= to =nil= to disable the default behavior
of =package-initialize= being run after processing of the =init.el=
file (see [[http://emacs.stackexchange.com/a/5888][here]]).

** =use-package=
Inspired by [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][this]] post, using =use-package= to ensure packages are
installed and initialize them lazily.

#+begin_src emacs-lisp
;; bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+end_src

** =auto-compile=
Package to ensure previously byte-compiled files never shadow changes
in the corresponding source (=.el=) file.
#+begin_src emacs-lisp
(require 'use-package)
(use-package auto-compile
  :ensure t
  :init (setq load-prefer-newer t)
  :config (auto-compile-on-load-mode))
#+end_src

** =custom-file=
The place where =custom-set-variables= decisions are persisted.
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom-settings.el" init-dir))
(load custom-file t)
#+end_src

** Startup buffer
Show =*scratch*= buffer on startup, rather than splash screen.
#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
#+end_src

* Global

** Editing
Universal editing configuration: how to handle whitespace, etc.
Largely lifted from =prelude-editor.el=.
*** Whitespace
#+begin_src emacs-lisp
;; Death to the tabs!  However, tabs historically indent to the next
;; 8-character offset; specifying anything else will cause *mass*
;; confusion, as it will change the appearance of every existing file.
;; In some cases (python), even worse -- it will change the semantics
;; (meaning) of the program.
;;
;; Emacs modes typically provide a standard means to change the
;; indentation width -- eg. c-basic-offset: use that to adjust your
;; personal indentation width, while maintaining the style (and
;; meaning) of any files you load.
(setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
(setq-default tab-width 8)            ;; but maintain correct appearance

;; Newline at end of file
(setq require-final-newline t)
#+end_src

**** =whitespace-mode=
Clean whitespace on save, highlight whitespace in buffers.
#+begin_src emacs-lisp
(defun my/enable-whitespace ()
  "Enable `whitespace-mode' and invoke `whitespace-cleanup' on file save."
  (add-hook 'before-save-hook #'whitespace-cleanup nil t)
  (whitespace-mode +1))

(use-package whitespace
  :diminish whitespace-mode
  :config
  (setq whitespace-line-column 80)
  (setq whitespace-style '(face tabs empty trailing lines-tail))
  (add-hook 'text-mode-hook #'my/enable-whitespace)
  (add-hook 'prog-mode-hook #'my/enable-whitespace))
#+end_src

*** Matching pairs (=smartparens-mode= and more)

The following block defines some keymappings for wrapping the active
region with a character (taken from prelude), it requires =smartparens-mode=.

#+begin_src emacs-lisp
(defun prelude-wrap-with (s)
  "Create a wrapper function for smartparens using S."
  `(lambda (&optional arg)
     (interactive "P")
     (sp-wrap-with-pair ,s)))

(defun partial-map-add (key fun)
  "Given a keymapping KEY -> FUN, return a function that takes a
keymap and adds the given mapping"
  `(lambda (keymap)
     (define-key keymap ,key ,fun)))

(setq my/wrap-mappings
      (mapcar (lambda (pair) (partial-map-add (car pair) (cdr pair)))
        '(((kbd "M-\"") . (prelude-wrap-with "\""))
          ((kbd "M-(") . (prelude-wrap-with "("))
          ((kbd "M-[") . (prelude-wrap-with "[")))))

(defun my/add-wrap-mappings (map)
  (mapc (lambda (mapping) (funcall mapping map)) my/wrap-mappings))

(my/add-wrap-mappings prog-mode-map)
(add-hook 'c-initialization-hook
          (lambda () (my/add-wrap-mappings c-mode-base-map)))
#+end_src

Here, we setup =smartparens= to show matching pairs and install its
=paredit=-style bindings.

#+begin_src emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :config
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)
  (setq sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1))
#+end_src

*** Typing replaces selection
Another bit of config from Prelude that I didn't realize I needed
until I ran Emacs without it. With this setting, typing replaces an
active selection, whereas the default behavior is that text is just
inserted at point regardless of the selection.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

*** =auto-fill-mode=
For programming modes, define the function =comment-auto-fill= to
disable auto-fill except for on comments. Taken from [[https://www.emacswiki.org/emacs/AutoFillMode][here]].

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'turn-on-auto-fill)
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(diminish 'auto-fill-function)
#+end_src

*** Expand at point

**** =hippie-expand=
Setup =hippie-expand=, which completes the word before point using one
of a variety of sources. Another bit of config taken verbatim from
Prelude

#+begin_src emacs-lisp
;; hippie expand is dabbrev expand on steroids
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))
(global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

**** =abbrev=
Enable =abbrev= for =text-mode= buffers.

#+begin_src emacs-lisp
(setq abbrev-file-name (expand-file-name "abbrev_defs" init-dir))
(add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
(diminish 'abbrev-mode)
#+end_src

Check out the manual for =abbrev-mode= [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs][here]]. In brief, the important
keybindings are:

- =C-x a g= :: Add global abbreviation for the word before point.
               Can call with a numeric prefix argument \(n\) to
               specify the number of words prior to point to define
               the abbreviation for.
- =C-x a l= :: Define an abbreviation as above, but that only applies
               to the current major mode.
- =C-x a i g= :: Use word before point as an abbreviation for a phrase
                 you define in the minibuffer.
- =M-x kill-all-abbrevs= :: Discard all abbrev definitions.

In order to type a prefix to an abbreviation (text that precedes the
expanded abbreviation without whitespace in between): type the prefix,
then type =M-=' followed by the abbreviation.

To type an abbreviation /without/ having it expand, type =C-q <SPC>=.

*** General indentation/formatting
Setup indentation/formatting bindings that apply in (nearly) any major
mode.

First, setup =<TAB>= to first indent the current line, then if the
line is already indented, complete the thing at point.
#+begin_src emacs-lisp
(setq tab-always-indent 'complete)
#+end_src

The next bit of code from Prelude makes

** Appearance

*** Leuven
#+begin_src emacs-lisp
(use-package leuven-theme
  :pin melpa
  :ensure t
  :init (load-theme 'leuven :no-confirm))
#+end_src

*** Disable Window Chrome
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

*** Disambiguate buffers with the same name
#+begin_src emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)     ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+end_src

*** Make =point= easier to find
Highlight the current line using =hl-line-mode=

#+begin_src emacs-lisp
(use-package hl-line
  :ensure t
  :config (global-hl-line-mode +1))
#+end_src

Animate the current line when making point jump/activating point in
another window
#+begin_src emacs-lisp
;; show the cursor when moving after big movements in the window
(use-package beacon
  :ensure t
  :config (beacon-mode +1))
#+end_src

** Behavior
*** Auto refresh buffer when associated file changes
#+srcname: name
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(diminish 'auto-revert-mode)
#+end_src

*** Change "yes or no" to "y or n"
Type out the full strings "yes" and "no"? Ain't nobody got time for that.
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Undo tree
=C-x u= on steroids: browse history of edits (undo and redo).
#+begin_src emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :ensure t
  :config
  ;; autosave the undo-tree history
  (setq undo-tree-history-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq undo-tree-auto-save-history t)
  (global-undo-tree-mode))
#+end_src

*** Sentences end with a single space
Saw this in Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][config]], and adopting it here. Allows
=forward-sentence= (=M-e=) and =backward-sentence= (=M-a=) to work as
expected.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

*** Prefer vertical splits
From [[http://stackoverflow.com/a/25587333/756104][this]] stack overflow answer, opens a new window with a vertical
split if there's sufficient room available, otherwise uses a
horizontal split.
#+begin_src emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 200)
#+end_src

*** Transpose Windows
Bind =C-c y= to transpose windows (a vertical split becomes a
horizontal one and vice versa). =C-c f= will swap buffers across $y$
axis, =C-c F= will swap buffers across $x$ axis.
#+begin_src emacs-lisp
(use-package transpose-frame
  :ensure t
  :bind (("C-c y" . transpose-frame)
         ("C-c f" . flop-frame)
         ("C-c F" . flip-frame)))
#+end_src


*** Backups/Persistence
Pretty much all this stuff is copied verbatim from Prelude. It gets
the =backup~= files out of the way, remembers where you last left in a
file, remembers minibuffer history, etc.

#+begin_src emacs-lisp
(defvar my/savefile-dir (expand-file-name "savefile" init-dir)
  "This folder stores all the automatically generated save/history-files.")

(unless (file-exists-p my/savefile-dir)
  (make-directory my/savefile-dir))
#+end_src

Store all backup files in temp directory, so as to not pollute the
project directory.
#+begin_src emacs-lisp
;; store all backup and autosave files in the tmp dir
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src


**** =recentf-mode=
I use =recentf-open-files= all the time.
#+begin_src emacs-lisp
(defun prelude-recentf-exclude-p (file)
  "A predicate to decide whether to exclude FILE from recentf."
  (let ((file-dir (file-truename (file-name-directory file))))
    (-any-p (lambda (dir)
              (string-prefix-p dir file-dir))
            (mapcar 'file-truename (list my/savefile-dir package-user-dir)))))

(use-package recentf
  :bind ("C-x C-r" . recentf-open-files)
  :config
  (setq recentf-save-file (expand-file-name "recentf" my/savefile-dir)
        recentf-max-saved-items 500
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)
  (add-to-list 'recentf-exclude 'prelude-recentf-exclude-p)
  (recentf-mode +1))
#+end_src

**** Save place in file
#+begin_src emacs-lisp
(use-package saveplace
  :ensure t
  :config
  (setq save-place-file (expand-file-name "saveplace" my/savefile-dir))
  ;; activate save-place for all buffers
  (setq-default save-place t))
#+end_src


**** Save minibuffer history
From Prelude, configure =savehist= to store the last few commands run
in the minibuffer, which persists across runs of emacs.
#+begin_src emacs-lisp
(use-package savehist
  :ensure t
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        savehist-file (expand-file-name "savehist" my/savefile-dir))
  (savehist-mode +1))
#+end_src

** Snippets
Fetch yasnippet, add the =other-snippets= directory to the path (where
I pull in additional snippets via git submodules).
#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :ensure t
  :init
  (setq yas-snippet-dirs
        `(,(expand-file-name "other-snippets" init-dir)
          ,(expand-file-name "snippets" init-dir)))
  (yas-global-mode 1)
  (yas-reload-all))
#+end_src

** Git

*** =magit-mode=
#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status))
#+end_src

*** Highlight uncommitted changes
#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :pin melpa
  :config
  (global-diff-hl-mode +1)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))
#+end_src

** =flyspell-mode=
Flyspell config, appropriate from Prelude.
#+begin_src emacs-lisp
(defun prelude-enable-flyspell ()
  "Enable command `flyspell-mode' if ispell program is available"
  (when (executable-find ispell-program-name)
    (flyspell-mode +1)))

(use-package flyspell
  :ensure t
  :diminish flyspell-mode
  :config
  (setq ispell-program-name "aspell" ; use aspell instead of ispell
        ispell-extra-args '("--sug-mode=ultra"))
  (add-hook 'text-mode-hook #'prelude-enable-flyspell))
#+end_src

Enable the Flyspell word correction dialog when there's a window
system available.
#+begin_src emacs-lisp
(if window-system (global-set-key (kbd "M-$") 'flyspell-correct-word-before-point))
#+end_src

* Org Mode

** Global Bindings
#+begin_src emacs-lisp
(global-set-key "\C-cl" #'org-store-link)
(global-set-key "\C-cb" #'org-iswitchb)
(use-package org-agenda :bind ("C-c a" . org-agenda))
(use-package org-capture :bind ([F6] . org-capture))
#+end_src


** Authoring Settings

*** Source block indentation
Disable Org's default behavior of indenting code from a source block
with spaces after saving back to buffer from =org-edit-src-code= (C-c ')
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
(setq org-edit-src-preserve-indentation nil)
#+end_src
*** Whitespace mode
Fix whitespace mode's naive =lines-tail= highlighting, so that only
the /description text/ of org mode links counts against the
=whitespace-line-column= limit. Inspired by example at
[[https://www.emacswiki.org/emacs/HighlightLongLines]].

#+begin_src emacs-lisp
;; a font-lock-keyword for org-mode. highlights parts of lines that extend past
;; whitespace-line-column, assuming that only the *description* of org links are
;; visible (and hence, only the descriptions count against the line length limit)

(defun my/advance-to-col (startpos startcol stopcol)
  "Given a start position STARTPOS in the current buffer, the column count
at point STARTPOS (STARTCOL) and desired end column (STOPCOL), return the
position of character starting column (STOPCOL+1)"
  (let ((curpos startpos)
        (curcols startcol))
    (while (< curcols stopcol)
      (setq curcols (+ curcols (char-width (char-after curpos))))
      (setq curpos (1+ curpos)))
    curpos))

(defun my/next-long-org-line (limit)
  "Return the next tuple (start end) of positions from current value of (point) to
be marked as entending past line length LIMIT."
  (catch 'done
    (while (< (line-beginning-position) limit)
      (beginning-of-line)
      (let ((curcols 0)
            (lim (min limit (line-end-position)))
            (curpos (point)))
        (while (re-search-forward org-bracket-link-analytic-regexp lim t)
          (let ((mstartcol (+ curcols
                              (string-width (buffer-substring
                                             (match-beginning 0) curpos))))
                labelwidth
                labelstart)
            (if (match-string 5)
                ;; link of the form [[proto:link][description]]
                (setq labelwidth (string-width (match-string 5))
                      labelstart (match-beginning 5))
              ;; link of the form [[proto:something]]
              (setq labelwidth (string-width (concat (match-string 1) (match-string 3)))
                    labelstart (match-beginning 1)))
            (when (>= mstartcol whitespace-line-column)
              ;; link starts after whitespace-line-column, wholesale mark everything
              ;; after whitespace-line-column
              (throw 'done (list (my/advance-to-col curpos curcols whitespace-line-column) lim)))
            (when (>= (+ mstartcol labelwidth) whitespace-line-column)
              ;; link starts before whitespace-line-column, but description (visible part)
              ;; extends past it
              (throw 'done (list (my/advance-to-col labelstart mstartcol whitespace-line-column) lim)))
            (setq curcols (+ mstartcol labelwidth)))
          (setq curpos (point)))
        ;; no org link match, see if line is just a long one
        (let ((advancecols (string-width (buffer-substring (point) (line-end-position)))))
          (when (>= (+ curcols advancecols) whitespace-line-column)
            (throw 'done (list (my/advance-to-col curpos curcols whitespace-line-column) lim)))))
      (if (< (1+ (line-end-position)) (point-max))
          (forward-line)
        (throw 'done nil)))))

(defun my/match-long-org (limit)
  (let ((match-range (my/next-long-org-line limit)))
    (when match-range
      (set-match-data match-range)
      (goto-char (1+ (cadr match-range))))
    ;; if we didn't find a match, match-range is nil, and this matcher is done
    match-range))

(setq my/org-bline-minor-mode-font-lock-keywords
      '((my/match-long-org 0 whitespace-line prepend)))

(define-minor-mode my/org-bline-minor-mode "Overlong lines can make you blined."
  nil nil nil
  (if my/org-bline-minor-mode
      (font-lock-add-keywords nil my/org-bline-minor-mode-font-lock-keywords t)
    (font-lock-remove-keywords nil my/org-bline-minor-mode-font-lock-keywords))
  (font-lock-mode 1))

(defun my/org-bline-minor-mode--insin ()
  (add-hook 'after-change-functions 'my/org-bline-minor-mode--uate nil t)
  ;; for debugging purposes, disable the JIT
  ;; (setq font-lock-support-mode nil)
  ;; (font-lock-mode -1)
  ;; (font-lock-mode 1)

  ;; get rid of the long line highlighting from whitespace-mode, we're doing
  ;; our own highlighting
  (whitespace-mode 0)
  (set (make-local-variable 'whitespace-style)
       (remove 'lines-tail whitespace-style))
  (whitespace-mode +1))

(defun my/org-bline-minor-mode--uate (&rest ignore)
  (my/org-bline-minor-mode 1)
  (remove-hook 'after-change-functions 'my/org-bline-minor-mode--uate t))

(add-hook 'org-mode-hook 'my/org-bline-minor-mode--insin)
#+end_src

** Tracking TODOs and Agenda
Log =TODO= state transitions in the =LOGBOOK= property drawer by default.
#+begin_src emacs-lisp
(setq org-log-into-drawer t)
#+end_src
Leuven theme doesn't make overdue agenda items sufficiently prominent

#+begin_src emacs-lisp
(set-face-attribute 'org-scheduled-previously nil
                    :foreground "red" :weight 'bold)
#+end_src

** Export

*** Pretty source blocks
Fontify source blocks in org buffer, and include the appropriate CSS
in HTML export
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
;; From http://emacs.stackexchange.com/q/3374
(defun my/org-inline-css-hook (exporter)
  "Insert custom inline css to automatically set the
background of code to whatever theme I'm using's background"
  (when (eq exporter 'html)
    (let* ((my-pre-bg (face-background 'default))
           (my-pre-fg (face-foreground 'default)))
      (setq
       org-html-head-extra
       (concat
        org-html-head-extra
        (format "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
                my-pre-bg my-pre-fg))))))
(add-hook 'org-export-before-processing-hook 'my/org-inline-css-hook)
#+end_src
* C Mode
** Editing
*** Disable =auto-fill-mode= except for comments

#+begin_src emacs-lisp
(add-hook 'c-mode-common-hook #'comment-auto-fill)
#+end_src
